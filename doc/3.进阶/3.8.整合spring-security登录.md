# 整合 spring-security 登录

## 前端组件调整

这里之前先调下样式，在 common.scss 添加一样内容卡片上边距

`spring-boot-activiti/web/src/assets/styles/common.scss`

````scss
.content-card {
  margin-top: 20px;

  .content-card-row {
    margin-bottom: 20px;
  }
}
````

- 前面说到封装一个 form 组件，这里添加一下，把之前的 form 表单都更换一下，添加 form/index.vue

`spring-boot-activiti/web/src/components/form/index.vue`

````vue

<template>
  <div class='form-container'>
    <!-- inline 属性可以让表单域变为行内的表单域 -->
    <el-form
        ref="dataFormRef"
        label-width="auto"
        :inline="inline"
        :model="form"
        :rules="rules"
    >
      <template v-for="formItem in formItems">
        <el-form-item
            :label="formItem.label"
            :prop="formItem.prop"
            :rules=formItem.rules
            v-if="condition(form, formItem)"
        >
          <!-- 没有定义或者定义为 text -->
          <template v-if="formItem.type === undefined || formItem.type === 'text'">
            <el-input v-model="form[formItem.prop]" clearable :placeholder="formItem.placeholder"
                      :suffix-icon="formItem.suffixIcon" :prefix-icon="formItem.prefixIcon"></el-input>
          </template>
          <template v-if="formItem.type === 'textarea'">
            <el-input v-model="form[formItem.prop]" type="textarea" :placeholder="formItem.placeholder"
                      :suffix-icon="formItem.suffixIcon" :prefix-icon="formItem.prefixIcon"></el-input>
          </template>
          <template v-if="formItem.type === 'password'">
            <el-input v-model="form[formItem.prop]" show-password clearable
                      :placeholder="formItem.placeholder" :suffix-icon="formItem.suffixIcon"
                      :prefix-icon="formItem.prefixIcon"></el-input>
          </template>
          <template v-if="formItem.type === 'switch'">
            <el-switch v-model="form[formItem.prop]" :active-icon="formItem.prefixIcon"
                       :inactive-icon="formItem.suffixIcon"></el-switch>
          </template>
          <template v-if="formItem.type === 'radio'">
            <el-radio-group v-model="form.designType" v-for="option in formItem.options">
              <el-radio :key="option.value" :value="option.value">{{ option.label }}</el-radio>
            </el-radio-group>
          </template>
          <template v-if="formItem.type === 'datetime'">
            <el-date-picker v-model="form[formItem.prop]" type="datetime" :placeholder="formItem.placeholder"
                            value-format="yyyy-MM-DD HH:mm:ss"/>
          </template>
        </el-form-item>
      </template>
      <!-- **注意**: Vue3 中使用具名插槽需要使用 template 进行包裹起来 -->
      <!-- 操作插槽, 具名插槽: 即 <slot> 元素上使用 name 属性用来标识插槽, , 还有默认插槽和作用域插槽 -->
      <slot name="buttons"></slot>
    </el-form>
  </div>
</template>

<script setup lang="ts">

  import {FormItem} from '@/components/form/form';
  import {FormInstance} from 'element-plus';
  import {nextTick, onMounted, ref} from 'vue';

  defineProps({
    // 表单对象
    form: {
      type: Object,
      default: () => {
        return {};
      }
    },
    // 表单校验规则
    rules: {
      type: Object,
      default: () => {
        return {};
      }
    },
    // 表单项配置
    formItems: {
      type: Array<FormItem>,
      default: () => {
        return [];
      }
    },
    // 是否为行内表单
    inline: {
      type: Boolean,
      default: false
    }
  });

  // Vue 3 写法, 获取 ref 定义的组件实例
  const dataFormRef = ref<FormInstance>();

  // 挂载完毕后执行的回调函数
  onMounted(() => {
    init();
  });

  // 初始化表单
  const init = () => {
    // 在 DOM 更新后执行回调
    nextTick(async () => {
      if (!dataFormRef.value) return;
      // 重置数据
      dataFormRef.value.resetFields();
    });
  };

  // 确认事件
  const validate = () => {
    if (!dataFormRef.value) return;
    return new Promise((resolve, reject) => {
      dataFormRef.value!.validate(async (valid, fields) => {
            if (valid) {
              resolve(true);
            } else {
              reject('未通过字段校验:' + fields);
            }
          }
      );
    });
  };

  // 表单项显示条件
  const condition = (form: any, formItem: FormItem) => {
    if (formItem.conditions) {
      for (let i = 0; i < formItem.conditions.length; i++) {
        const ele = formItem.conditions[i];
        if (form[ele.prop] !== ele.value) {
          return false;
        }
      }
    }
    return true;
  };

  // 在 <script setup> 中, 所有定义的变量和函数默认是私有的, 不能从组件外部访问, 通过 defineExpose 显式指定暴露方法
  defineExpose({
    init, validate
  });
</script>

<style scoped lang='scss'>

</style>
````

类型声明

`spring-boot-activiti/web/src/components/form/form.d.ts`

````typescript
// declare关键字用于告诉编译器某个标识符已经存在，但不需要进行类型检查
// 表格列配置
import {FormItemRule} from 'element-plus';
import {Arrayable} from 'element-plus/es/utils';

declare interface FormItem {
  // 属性名
  prop: string,
  // 显示名称
  label?: string,
  // 自定义前缀图标
  prefixIcon?: string,
  // 自定义后缀图标
  suffixIcon?: string,
  // 表单项类型
  type?: InputType,
  // 表单项显示条件
  conditions?: Condition[],
  // 选项配置
  options?: Option[],
  // 提示语
  placeholder?: string,
  // 表单校验规则
  rules?: Arrayable<FormItemRule>,
}

// 定义字面量类型的联合类型, 给变量赋值, 只能赋联合类型中定义的字面量值
type InputType = undefined | 'text' | 'textarea' | 'password' | 'radio' | 'switch' | 'datetime';

// 选项配置
declare interface Option {
  // 选项值
  value: string | number | boolean,
  // 选项名称
  label: string,
}

// 显示条件
declare interface Condition {
  // 属性名
  prop: string,
  // 属性值
  value: string | number | boolean,
}
````

- 修改之前使用 form 的地方，改为自定义的组件，这里统一一下 form 的名称，searchForm 为搜索表单，dataForm 为内容表单：

先修改搜索表单，definition/index.vue，deployment/index.vue，model/index.vue 对应的搜索表单区域调整一下

````vue

<template>
  <!-- 搜索表单区域 -->
  <Form
      inline
      :form="searchForm"
      :formItems="searchFormItems"
  >
    <template #buttons>
      <el-form-item>
        <el-button type="primary" icon="Search" @click="handlerSearch">查 询</el-button>
      </el-form-item>
    </template>
  </Form>
</template>

<script setup lang="ts">
  import Form from '@/components/form/index.vue';
  // 搜索表单
  const searchForm = reactive<QueryPageBean>({
    keywords: ''
  });
  // 搜索表单项
  const searchFormItems = reactive<FormItem[]>([
    {
      prop: 'keywords',
      label: '关键词',
      placeholder: '关键词'
    }
  ]);
</script>
````

- 接着是 definition/index.vue 的激活/挂起表单：

````vue

<template>
  <!-- 挂起/激活弹窗 -->
  <el-dialog :title="suspended ? '激活' : '挂起'" v-model="suspendedVisible" style="max-width: 500px;padding: 30px"
             :before-close="handlerCloseSuspended">
    <Form
        ref="dataFormRef"
        :form="dataForm"
        :formItems="dataFormItems"
    >
    </Form>
    <template #footer>
      <div class="dialog-footer">
        <el-button @click="handlerCloseSuspended">取 消</el-button>
        <el-button type="primary" @click="handlerConfirmSuspended">确 定</el-button>
      </div>
    </template>
  </el-dialog>
</template>

<script setup lang="ts">
  // Vue 3 写法, 获取 ref 定义的组件实例
  const dataFormRef = ref<FormInstance>();
  // 表单参数
  const dataForm = reactive<SuspendDefinitionDTO>({
    id: '',
    activateProcessInstances: true,
    activationDate: ''
  });
  const dataFormItems = reactive<FormItem[]>([
    {
      prop: 'activateProcessInstances',
      label: (suspended ? '激活' : '挂起') + '关联流程实例',
      placeholder: '请选择定时' + (suspended ? '激活' : '挂起') + '时间',
      type: 'switch'
    },
    {
      prop: 'activationDate',
      label: '定时' + (suspended ? '激活' : '挂起') + '时间',
      placeholder: '请选择定时' + (suspended.value ? '激活' : '挂起') + '时间',
      type: 'datetime'
    }
  ]);

  // 确定挂起/激活
  const handlerConfirmSuspended = async () => {
    if (!dataFormRef.value) return;
    const validate = await dataFormRef.value.validate();
    if (validate) {
      let res;
      if (suspended.value) {
        // 设置是否挂起为 false
        suspended.value = false;
        res = await activate(dataForm.id, dataForm);
      } else {
        // 设置是否挂起为 true
        suspended.value = true;
        res = await suspend(dataForm.id, dataForm);
      }
      if (res.code === 200 && res.data) {
        ElMessage({message: suspended.value ? '挂起成功' : '激活成功', type: 'success'});
        // 搜索刷新列表
        await getData();
        // 关闭弹窗
        handlerCloseSuspended();
      } else {
        ElMessage({message: res.msg, type: 'error'});
      }
    }
  };
</script>
````

- 还有新增/编辑模型中的 el-form

`spring-boot-activiti/web/src/views/process/model/form-model.vue`

````vue

<template>
  <div class='definition-container'>
    <!-- 通过shadow属性设置卡片阴影出现的时机：always、hover或never -->
    <el-card shadow="always" class="search-card">
      <!-- 搜索表单区域 -->
      <Form
          inline
          :form="searchForm"
          :formItems="searchFormItems"
      >
        <template #buttons>
          <el-form-item>
            <el-button type="primary" icon="Search" @click="handlerSearch">查 询</el-button>
          </el-form-item>
        </template>
      </Form>
    </el-card>

    <el-card shadow="always" class="content-card">
      <!-- 表格区域 -->
      <Table
          :columns="columns"
          :data="data"
          showPagination
          @pagination="paginationChange"
          :paginationData="paginationData"
      >
        <template #buttons>
          <el-table-column fixed="right" align="center" label="操作" min-width="120" width="240">
            <template #default="scope">
              <el-button
                  icon="Outline"
                  @click="handlerShow(scope.row)"
                  text
                  style="color: #ff5f00"
              >查看流程文件
              </el-button
              >
              <el-button
                  icon="View"
                  @click="handlerShowChart(scope.row)"
                  text
                  style="color: rgba(6,190,213,0.98)"
              >查看流程图
              </el-button
              >
              <el-button
                  icon="View"
                  @click="handlerShowChartBpmnJs(scope.row)"
                  text
                  style="color: rgb(128,105,105)"
              >查看流程图(bpmn-js)
              </el-button
              >
              <el-button
                  icon="Flag"
                  @click="handlerExchangeModel(scope.row)"
                  text
                  style="color: #b700ff"
              >转为模型
              </el-button
              >
              <el-button
                  :icon="scope.row.suspended ? 'Play' : 'Pause'"
                  @click="handlerSuspended(scope.row)"
                  text
                  :style="'color: ' + (scope.row.suspended ? 'rgb(68,179,3)' : 'blue')"
              >{{ scope.row.suspended ? '激活' : '挂起' }}
              </el-button
              >
            </template>
          </el-table-column>
        </template>
      </Table>
    </el-card>

    <!-- 流程文件预览弹窗 -->
    <el-dialog title="流程文件预览" v-model="processDefineVisible" width="85%" top="3vh" style="padding: 10px"
               :before-close="handlerCloseProcessDefineVisible">
      <pre>
        <code class="hljs" v-html="highlightedCode()"></code>
      </pre>
      <template #footer>
        <div class="dialog-footer">
          <el-button type="primary" @click="handlerCloseProcessDefineVisible">关 闭</el-button>
        </div>
      </template>
    </el-dialog>

    <!-- 流程图预览 -->
    <el-dialog title="流程图预览" v-model="processChartVisible"
               :before-close="handlerCloseProcessChart">
      <template v-if="showBpmnProcess">
        <!-- 画布 -->
        <div id="canvas" ref="canvasRef"></div>
      </template>
      <template v-else>
        <img :src="img">
      </template>
      <template #footer>
        <div class="dialog-footer">
          <el-button type="primary" @click="handlerCloseProcessChart">关 闭</el-button>
        </div>
      </template>
    </el-dialog>

    <!-- 挂起/激活弹窗 -->
    <el-dialog :title="suspended ? '激活' : '挂起'" v-model="suspendedVisible" style="max-width: 500px;padding: 30px"
               :before-close="handlerCloseSuspended">
      <Form
          ref="dataFormRef"
          :form="dataForm"
          :formItems="dataFormItems"
      >
      </Form>
      <template #footer>
        <div class="dialog-footer">
          <el-button @click="handlerCloseSuspended">取 消</el-button>
          <el-button type="primary" @click="handlerConfirmSuspended">确 定</el-button>
        </div>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">

  import Table from '@/components/table/index.vue';
  import Form from '@/components/form/index.vue';
  import {markRaw, onMounted, reactive, ref} from 'vue';
  import {QueryPageBean} from '@/utils/http/axios/axios';
  import {
    activate,
    exchangeToModel,
    getByPaged,
    show,
    showChart,
    showChartBpmnJs,
    suspend
  } from '@/api/process/definition.ts';
  // 设计器, bpmn-js有两种模式: Modeler 模式和 Viewer 模式, 在 Modeler 模式下可以对流程图进行编辑, 而 Viewer 模式则不能, 仅作为展示用
  import ViewerModeler from 'bpmn-js/lib/Viewer';

  import {Action, ElMessage, ElMessageBox, FormInstance} from 'element-plus';
  import hljs from 'highlight.js';
  // 加载默认主题
  // import 'highlight.js/styles/default.css';
  // dark
  // import 'highlight.js/styles/github-dark.css';
  // 高亮主题, 还有一些其他主题都在 highlight.js/styles 目录下, 可以自己切换
  import 'highlight.js/styles/intellij-light.css';
  import {FormItem} from '@/components/form/form';

  // reactive 一般定义响应式数据, 例如数组、对象等, ref 一般定义基础类型数据, 例如字符串、数字等

  // 流程文件预览弹窗是否显示
  const processDefineVisible = ref(false);
  // 流程图预览弹窗是否显示
  const processChartVisible = ref(false);
  // 挂起/激活弹窗是否显示
  const suspendedVisible = ref(false);
  // 是否显示 bpmn-js 流程图
  const showBpmnProcess = ref(false);
  // activiti-modeler 流程图片
  const img = ref();
  // 流程文件内容
  const text = ref('');
  // 挂起/激活状态
  const suspended = ref(false);
  // bpmn-js 流程图实例
  const bpmnModeler = ref();
  // Vue 3 写法, 获取 ref 定义的组件实例
  const canvasRef = ref();

  // 表格数据集
  const data = ref([]);
  // 表格列配置
  const columns = reactive<Column[]>([
    {
      prop: 'name',
      label: '部署名称',
      width: 140
    },
    {
      prop: 'key',
      label: '关键字'
    },
    {
      prop: 'category',
      label: '类型'
    },
    {
      prop: 'version',
      label: '版本',
      width: 100
    },
    {
      prop: 'resourceName',
      label: '资源路径'
    },
    {
      prop: 'diagramResourceName',
      label: '图片资源文件名称',
      width: 180
    },
    {
      prop: 'suspended',
      label: '状态',
      width: 180,
      option: [
        {
          value: false,
          label: '激活',
          tagType: 'success'
        },
        {
          value: true,
          label: '挂起',
          tagType: 'warning'
        }
      ]
    },
    {
      prop: 'appVersion',
      label: '自定义应用版本号',
      width: 120
    }
  ]);
  // 分页参数
  const paginationData = reactive<Pagination>({
    size: 10,
    current: 1,
    total: 0
  });
  // 搜索表单
  const searchForm = reactive<QueryPageBean>({
    keywords: ''
  });
  // 搜索表单项
  const searchFormItems = reactive<FormItem[]>([
    {
      prop: 'keywords',
      label: '关键词',
      placeholder: '关键词'
    }
  ]);
  // Vue 3 写法, 获取 ref 定义的组件实例
  const dataFormRef = ref<>();
  // 表单参数
  const dataForm = reactive<SuspendDefinitionDTO>({
    id: '',
    activateProcessInstances: true,
    activationDate: ''
  });
  // 表单项
  const dataFormItems = reactive<FormItem[]>([
    {
      prop: 'activateProcessInstances',
      label: (suspended ? '激活' : '挂起') + '关联流程实例',
      placeholder: '请选择定时' + (suspended ? '激活' : '挂起') + '时间',
      type: 'switch'
    },
    {
      prop: 'activationDate',
      label: '定时' + (suspended ? '激活' : '挂起') + '时间',
      placeholder: '请选择定时' + (suspended.value ? '激活' : '挂起') + '时间',
      type: 'datetime'
    }
  ]);

  // 挂载完毕后执行的回调函数
  onMounted(() => {
    getData();
  });

  // 点击搜索按钮
  const handlerSearch = () => {
    getData();
  };

  // 获取表格数据
  const getData = async () => {
    const res = await getByPaged({...searchForm, ...paginationData});
    if (res.code === 200 && res.data) {
      data.value = res.data.rows;
      paginationData.total = res.data.total;
    } else {
      ElMessage({message: res.msg, type: 'error'});
    }
  };

  // 分页改变调用的事件
  const paginationChange = (data: ProcessDefinitionVO) => {
    // 把原来的值覆盖
    Object.assign(paginationData, {...paginationData, ...data});
    getData();
  };

  // 点击查看流程文件按钮
  const handlerShow = async (row: ProcessDefinitionVO) => {
    processDefineVisible.value = true;
    const res = await show(row.deploymentId, {resourceName: row.resourceName});
    if (res.code === 200 && res.data) {
      text.value = res.data;
    } else {
      ElMessage({message: res.msg, type: 'error'});
    }
  };

  /** 高亮显示 */
  const highlightedCode = () => {
    const result = hljs.highlight(text.value, {language: 'xml', ignoreIllegals: true});
    return result.value || '&nbsp;';
  };

  // 点击查看流程图
  const handlerShowChart = async (row: ProcessDefinitionVO) => {
    // 设置是否显示 bpmn-js 流程图为 false
    showBpmnProcess.value = false;
    // 显示流程图弹窗
    processChartVisible.value = true;
    // 转换流响应到弹窗
    const res = await showChart(row.id);
    if (typeof window !== 'undefined' && window.URL) {
      // 将 blob 对象 生成 BlobURL
      img.value = window.URL.createObjectURL(res);
    }
  };

  // 点击查看流程图(bpmn-js)
  const handlerShowChartBpmnJs = async (row: ProcessDefinitionVO) => {
    // 设置是否显示 bpmn-js 流程图为 true
    showBpmnProcess.value = true;
    // 显示流程图弹窗
    processChartVisible.value = true;
    if (bpmnModeler.value) {
      // 如果存在就销毁重新创建，否则会不停添加流程
      bpmnModeler.value.destroy();
    }
    // 调用接口获取流程图 xml
    const res = await showChartBpmnJs(row.id);
    if (res.code === 200 && res.data) {
      // toRaw 方法可以将一个被 reactive 包裹的对象还原为其中的原始对象，从而使其不再具有任何响应式能力。
      // markRaw 方法可以将一个对象标记为非响应式，从而使其不会被 reactive 包裹，也就不会成为 Vue3 中的响应式对象。
      // BpmnViewer 预览、BpmnModeler 操作
      bpmnModeler.value = markRaw(new ViewerModeler({
        container: canvasRef.value
      }));
      await bpmnModeler.value.importXML(res.data);
      const canvas = bpmnModeler.value.get('canvas');
      // 使流程图自适应屏幕
      canvas.zoom('fit-viewport', 'auto');
      canvas.zoom(0.8); //缩写至0.8倍
    }
  };

  // 点击转为模型按钮
  const handlerExchangeModel = async (row: ProcessDefinitionVO) => {
    // 给个默认值 3, 关闭弹框操作
    let designType: number = 3;
    await ElMessageBox.confirm('是否确认转换名称为"' + row.name + '"的流程定义为模型？', '转换模型', {
          confirmButtonText: '转换为 bpmn-js',
          cancelButtonText: '转换为 activiti-modeler',
          // 如果将 distinguishCancelAndClose 属性设置为 true, 则上述两种行为的参数分别为 'cancel' 和 'close'。
          distinguishCancelAndClose: true,
          type: 'success'
        }
    ).then(async () => {
      // 转换为 bpmn-js
      designType = 2;
    }).catch((action: Action) => {
      // 区分取消操作与关闭操作, 有些场景下，点击取消按钮与点击关闭按钮有着不同的含义
      // 默认情况下, 当用户触发取消 ( 点击取消按钮 ) 和触发关闭 ( 点击关闭按钮或遮罩层, 按下 ESC 键 ) 时. Promise 的 reject 回调和 callback 回调的参数均为 'cancel'
      if (action === 'cancel') {
        // 转换为 activiti-modeler
        designType = 1;
      } else {
        // 关闭弹框操作
        designType = 3;
        // 关闭弹框操作
        return;
      }
    });
    if (designType === 3) return;
    const res = await exchangeToModel(row.id, designType);
    if (res.code === 200 && res.data) {
      await getData();
      ElMessage({type: 'success', message: '转换成功'});
    } else {
      ElMessage({type: 'error', message: res.msg});
    }
  };

  // 点击激活/挂起按钮
  const handlerSuspended = async (row: ProcessDefinitionVO) => {
    dataForm.id = row.id;
    suspended.value = row.suspended;
    suspendedVisible.value = true;
  };

  // 关闭流程文件预览弹窗
  const handlerCloseProcessDefineVisible = () => {
    processDefineVisible.value = false;
  };

  // 关闭流程图预览弹窗
  const handlerCloseProcessChart = () => {
    processChartVisible.value = false;
  };

  // 关闭挂起/激活弹窗
  const handlerCloseSuspended = () => {
    suspendedVisible.value = false;
  };

  // 确定挂起/激活
  const handlerConfirmSuspended = async () => {
    if (!dataFormRef.value) return;
    const validate = await dataFormRef.value.validate();
    if (validate) {
      let res;
      if (suspended.value) {
        // 设置是否挂起为 false
        suspended.value = false;
        res = await activate(dataForm.id, dataForm);
      } else {
        // 设置是否挂起为 true
        suspended.value = true;
        res = await suspend(dataForm.id, dataForm);
      }
      if (res.code === 200 && res.data) {
        ElMessage({message: suspended.value ? '挂起成功' : '激活成功', type: 'success'});
        // 搜索刷新列表
        await getData();
        // 关闭弹窗
        handlerCloseSuspended();
      } else {
        ElMessage({message: res.msg, type: 'error'});
      }
    }
  };
</script>
````

- 把新增按钮区域的<el-form> 标签去掉，换成 <row>，这里用 <el-form> 没啥意义

`spring-boot-activiti/web/src/views/process/model/index.vue`

````vue
<!-- 新增按钮区域 -->
<el-row class="content-card-row">
  <el-button
      icon="Plus"
      type="primary"
      plain
      @click="handlerAdd"
  >
    新增
  </el-button>
</el-row>
````

`spring-boot-activiti/web/src/views/process/deployment/index.vue`

````vue
<!-- 新增按钮区域 -->
<el-row class="content-card-row">
  <el-button
      icon="Plus"
      type="primary"
      plain
      @click="handlerUpload"
  >
    上传流程文件
  </el-button>
</el-row>
````

## spring-security

- spring-security 默认自带登录页面，但这里的项目是前后端分离的，所以使用自定义登录接口和登录页面。

- 在这之前扩展一下：RBAC（Role-Based Access Control）基于角色的访问控制。

  https://www.cnblogs.com/guosiliang/p/13731501.html

    - 为什么要引入RBAC模型

    ````
    在传统的权限模型之中，没有角色的概念。把权限赋给用户，会导致在配置权限的时候会相当的麻烦，并且无法快速为多个用户批量删除权限。
  
    在RBAC中，增加了“角色”的概念，将权限赋予角色，再将角色赋予用户。用户——角色——权限多对多的关系解决了上述传统模型的问题。
  
    关键的元素：
  
    用户：成功认证并登录系统的操作员。
  
    角色：权限的集合，也是用户和权限之间的桥梁。
  
    权限：访问资源的许可，含有页面权限、操作权限和数据权限。
  
    资源：引入这第四个概念，包括系统菜单、页面、按钮等
    ````

    - RBAC的分类：

      根据权限的复杂程度，将RBAC又分四种：RBAC0、RBAC1、RBAC2、RBAC3

      ````
      RBAC0 基本模型：用户分配角色，角色分配权限，用户-角色-权限形成多对多关系。
      RBAC1 角色分层模型：建立在RBAC0的基础之上，在角色中增加了继承的概念，在父角色的基础上进行删减权限。
      RBAC2 角色限制模型：建立在RBAC0的基础之上增加了限制，分为静态职责分离 SSD ( Static Separation of Duty )和动态职责分离 DSD ( Dynamic Separation of Duty )：
            静态职责分离 SSD：
                      互斥角色限制：一个用户不能同时分配互斥角色中的多个角色，即只能选择一个。
                      基数限制：一个用户拥有的角色是有限的。
                      先决条件限制：一个用户想获得更高级的角色，首先需先拥有低级角色。
            动态职责分离 DSD：
                      动态限制：一个用户可以拥有两个角色，但是运行时只能激活一个角色。
      RBAC3 统一模型：RBAC3 = RBAC1 + RBAC2，既包含了角色分层，也包含了角色限制
      ````
    - RBAC模型之外权限：

        - 用户组：用户组分配角色，再把用户加入用户组，一个用户的权限 = 该用户所拥有角色的权限 + 该用户所属的用户组所拥有角色的权限
        - 数据数据：限制为'本人/本部门/下级部门/本部门和下级部门/自定义部门/全部'等属性，以控制用户对于不同范围的数据查看权限。

- 这里我们使用基本模型就够了，即：用户分配角色，角色分配菜单(权限)；

相关表结构，用户表、用户关联角色表、角色表、角色关联菜单表、菜单表，其中菜单分为页面和按钮

````sql
-- ================================================================================================================================
-- 系统用户表
drop table if exists `sys_user`;
CREATE TABLE `sys_user`
(
    `id`          bigint unsigned                        NOT NULL AUTO_INCREMENT COMMENT '主键',
    `username`    varchar(32) COLLATE utf8mb4_general_ci NOT NULL COMMENT '用户名',
    `password`    varchar(32) COLLATE utf8mb4_general_ci NOT NULL COMMENT '密码(MD5加密)',
    `name`        varchar(32) COLLATE utf8mb4_general_ci NOT NULL COMMENT '姓名',
    `avatar`      longtext COLLATE utf8mb4_general_ci COMMENT '头像 base64 存储',
    `enabled`     tinyint(1) unsigned                    NOT NULL DEFAULT '0' COMMENT '状态:0-启用;1-禁用;',
    `tenant_id`   bigint unsigned                        NOT NULL DEFAULT '0' COMMENT '租户id',
    `create_time` datetime                               NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` datetime                               NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `uq_username` (`username`) USING BTREE
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_general_ci COMMENT ='系统用户表';
-- ================================================================================================================================
-- 系统用户角色关联表
drop table if exists `sys_user_role`;
CREATE TABLE `sys_user_role`
(
    `id`          bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
    `user_id`     bigint unsigned NOT NULL COMMENT '用户id',
    `role_id`     bigint unsigned NOT NULL COMMENT '角色id',
    `create_time` datetime        NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `uq_user_id_role_id` (`user_id`, `role_id`) USING BTREE
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_general_ci COMMENT ='系统用户角色关联表';
-- ================================================================================================================================
-- 系统角色表
drop table if exists `sys_role`;
CREATE TABLE `sys_role`
(
    `id`          bigint unsigned                        NOT NULL AUTO_INCREMENT COMMENT '主键',
    `name`        varchar(32) COLLATE utf8mb4_general_ci NOT NULL COMMENT '名称',
    `code`        varchar(32) COLLATE utf8mb4_general_ci NOT NULL COMMENT '编码',
    `description` varchar(256) COLLATE utf8mb4_general_ci         DEFAULT NULL COMMENT '描述',
    `enabled`     tinyint(1) unsigned                    NOT NULL DEFAULT '0' COMMENT '状态:0-启用;1-禁用;',
    `tenant_id`   bigint unsigned                        NOT NULL DEFAULT '0' COMMENT '租户id',
    `create_time` datetime                               NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` datetime                               NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_general_ci COMMENT ='系统角色表';
-- ================================================================================================================================
-- 系统角色菜单关联表
drop table if exists `sys_role_menu`;
CREATE TABLE `sys_role_menu`
(
    `id`          bigint unsigned NOT NULL AUTO_INCREMENT COMMENT '主键',
    `role_id`     bigint unsigned NOT NULL COMMENT '角色id',
    `menu_id`     bigint unsigned NOT NULL COMMENT '菜单id',
    `create_time` datetime        NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `uq_menu_id_role_id` (`menu_id`, `role_id`) USING BTREE
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_general_ci COMMENT ='系统角色菜单关联表';
-- ================================================================================================================================
-- 系统菜单表
drop table if exists `sys_menu`;
CREATE TABLE `sys_menu`
(
    `id`          bigint unsigned                         NOT NULL AUTO_INCREMENT COMMENT '主键',
    `name`        varchar(64) COLLATE utf8mb4_general_ci  NOT NULL COMMENT '名称',
    `icon`        varchar(256) COLLATE utf8mb4_general_ci          DEFAULT NULL COMMENT '图标',
    `code`        varchar(128) COLLATE utf8mb4_general_ci NOT NULL COMMENT '编码',
    `path`        varchar(256) COLLATE utf8mb4_general_ci NOT NULL COMMENT '路由',
    `visible`     tinyint(1) unsigned                     NOT NULL DEFAULT '0' COMMENT '显示状态:0-显示;1-隐藏',
    `parent_id`   bigint unsigned                         NOT NULL DEFAULT '0' COMMENT '父菜单id(0为一级菜单)',
    `sort_num`    int unsigned                            NOT NULL DEFAULT '1' COMMENT '排序编号',
    `enabled`     tinyint(1) unsigned                     NOT NULL DEFAULT '0' COMMENT '状态:0-启用;1-禁用;',
    `type`        tinyint(1) unsigned                     NOT NULL DEFAULT '0' COMMENT '类别:0-菜单;1-按钮;',
    `tenant_id`   bigint unsigned                         NOT NULL DEFAULT '0' COMMENT '租户id',
    `create_time` datetime                                NOT NULL DEFAULT CURRENT_TIMESTAMP COMMENT '创建时间',
    `update_time` datetime                                NOT NULL DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP COMMENT '更新时间',
    PRIMARY KEY (`id`) USING BTREE,
    UNIQUE KEY `UNIQUE_CODE` (`code`) USING BTREE
) ENGINE = InnoDB
  DEFAULT CHARSET = utf8mb4
  COLLATE = utf8mb4_general_ci COMMENT ='系统菜单表';

INSERT INTO `sys_user` (`id`, `username`, `password`, `name`, `enabled`, `tenant_id`, `create_time`,
                        `update_time`)
VALUES (1, 'admin', 'e10adc3949ba59abbe56e057f20f883e', 'admin', 0, 0, now(), now()),
       (2, 'ggb', 'e10adc3949ba59abbe56e057f20f883e', 'gg蹦', 0, 0, now(), now()),
       (3, 'fyy', 'e10adc3949ba59abbe56e057f20f883e', '沸羊羊', 0, 0, now(), now()),
       (4, 'smg', 'e10adc3949ba59abbe56e057f20f883e', '双面龟', 0, 0, now(), now()),
       (5, 'hxh', 'e10adc3949ba59abbe56e057f20f883e', '黑小虎', 0, 0, now(), now());
````

最后的 insert 脚本，添加 5 个用户用于登录测试。

### 后端

1. 添加依赖：

````xml
<!-- security -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-starter-security</artifactId>
</dependency>
````

2. 配置用户获取方式：

- User 数据库实体类

`io.github.cmmplb.activiti.domain.entity.User`

````java
package io.github.cmmplb.activiti.domain.entity;

import com.baomidou.mybatisplus.annotation.*;
import lombok.Data;

import java.io.Serializable;
import java.util.Date;

/**
 * @author penglibo
 * @date 2024-11-06 16:26:30
 * @since jdk 1.8
 */

@Data
@TableName(value = "sys_user")
public class User implements Serializable {

    private static final long serialVersionUID = 1L;

    /**
     * 主键
     */
    @TableId(value = "id", type = IdType.AUTO)
    private Long id;

    /**
     * 用户名
     */
    @TableField(value = "username")
    private String username;

    /**
     * 密码
     */
    @TableField(value = "password")
    private String password;

    /**
     * 姓名
     */
    @TableField(value = "name")
    private String name;

    /**
     * 头像 base64 存储
     */
    @TableField(value = "avatar")
    private String avatar;

    /**
     * 状态:0-启用;1-禁用;
     */
    @TableField(value = "enabled")
    private Byte enabled;

    /**
     * 租户id
     */
    @TableField(value = "tenant_id")
    private Byte tenantId;

    /**
     * 创建时间
     */
    @TableField(value = "create_time", fill = FieldFill.INSERT)
    private Date createTime;

    /**
     * 更新时间
     */
    @TableField(value = "update_time")
    private Date updateTime;
}
````

- Security 用户对象 UserDetails：

`io.github.cmmplb.activiti.security.UserDetails`

````java
package io.github.cmmplb.activiti.security;

import lombok.Data;
import lombok.Setter;
import org.springframework.security.core.authority.SimpleGrantedAuthority;

import java.util.ArrayList;
import java.util.Collection;
import java.util.List;

/**
 * @author penglibo
 * @date 2024-11-06 16:36:04
 * @since jdk 1.8
 */

@Data
public class UserDetails implements org.springframework.security.core.userdetails.UserDetails {

    private static final long serialVersionUID = -2595868307427612138L;

    /**
     * 主键
     */
    private Long id;

    /**
     * 用户名
     */
    private String username;

    /**
     * 密码
     */
    private String password;

    /**
     * 姓名
     */
    private String name;

    /**
     * 头像 base64 存储
     */
    private String avatar;

    /**
     * 是否没有过期, 用户的帐号是否已过期, 过期的帐户无法*进行身份验证
     */
    private boolean accountNonExpired = true;

    /**
     * 是否没有锁定, 指示用户是被锁定还是未锁定,无法对锁定的用户进行身份验证.
     */
    private boolean accountNonLocked = true;

    /**
     * 是否没有过期, 指示用户的凭据（密码）是否已过期. 过期的 * 凭据会阻止身份验证.
     */
    private boolean credentialsNonExpired = true;

    /**
     * 是否启用, 指示用户是启用还是禁用. 禁用的用户无法验证
     */
    private boolean enabled = true;

    // 授予用户的权限
    @Setter
    private List<SimpleGrantedAuthority> authorities = new ArrayList<>();

    @Override
    public Collection<? extends SimpleGrantedAuthority> getAuthorities() {
        return authorities;
    }
}
````

- UserMapper：

``

````java
package io.github.cmmplb.activiti.dao;

import com.baomidou.mybatisplus.core.mapper.BaseMapper;
import io.github.cmmplb.activiti.domain.entity.User;

/**
 * @author penglibo
 * @date 2024-11-06 16:31:48
 * @since jdk 1.8
 * mybatis-plus 支持不需要 Mapper.xml
 */

public interface UserMapper extends BaseMapper<User> {
}
````

- UserService：

````java
package io.github.cmmplb.activiti.service;

import com.baomidou.mybatisplus.extension.service.IService;
import io.github.cmmplb.activiti.domain.entity.User;
import org.springframework.security.core.userdetails.UserDetailsService;

/**
 * @author penglibo
 * @date 2024-11-06 16:32:43
 * @since jdk 1.8
 */
public interface UserService extends UserDetailsService, IService<User> {
}
````

- UserServiceImpl，之前已经定义过一个了，之前的是固定的一个 admin，这里调整一下，从数据库查询，注意这里的 User 实体的包名不是
  security，更换成 domain/entity：

`io.github.cmmplb.activiti.service.impl.UserServiceImpl`

````java
package io.github.cmmplb.activiti.service.impl;

import com.baomidou.mybatisplus.core.conditions.query.LambdaQueryWrapper;
import com.baomidou.mybatisplus.extension.service.impl.ServiceImpl;
import io.github.cmmplb.activiti.dao.UserMapper;
import io.github.cmmplb.activiti.domain.entity.User;
import io.github.cmmplb.activiti.security.UserDetails;
import io.github.cmmplb.activiti.service.UserService;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.core.userdetails.UsernameNotFoundException;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.stereotype.Service;

import java.util.ArrayList;

/**
 * @author penglibo
 * @date 2024-10-19 23:32:24
 * @since jdk 1.8
 */

@Slf4j
@Service
public class UserServiceImpl extends ServiceImpl<UserMapper, User> implements UserService {

    @Autowired
    private PasswordEncoder passwordEncoder;

    @Override
    public UserDetails loadUserByUsername(String username) throws UsernameNotFoundException {
        User user = baseMapper.selectOne(new LambdaQueryWrapper<User>().eq(User::getUsername, username));
        if (user == null) {
            throw new UsernameNotFoundException("用户名不存在");
        }
        UserDetails userDetails = new UserDetails();
        userDetails.setId(user.getId());
        userDetails.setUsername(user.getUsername());
        userDetails.setPassword(passwordEncoder.encode(user.getPassword()));
        userDetails.setName(user.getName());
        userDetails.setAvatar(user.getAvatar());
        userDetails.setEnabled(user.getEnabled().equals((byte) 0));
        userDetails.setAuthorities(new ArrayList<>());
        return userDetails;
    }
}
````

3. 配置 Security ：

`io.github.cmmplb.activiti.configuration.WebSecurityConfigurer`

````java
package io.github.cmmplb.activiti.configuration;

import io.github.cmmplb.activiti.security.filter.AuthenticationFilter;
import io.github.cmmplb.activiti.security.handler.AccessDeniedHandler;
import io.github.cmmplb.activiti.security.handler.ResourceAuthenticationEntryPoint;
import io.github.cmmplb.activiti.service.UserService;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.ProviderManager;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configurers.AbstractHttpConfigurer;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

/**
 * @author penglibo
 * @date 2024-10-19 22:36:23
 * @since jdk 1.8
 */

@Configuration
public class WebSecurityConfigurer {

    @Autowired
    private UserService userService;

    @Autowired
    private PasswordEncoder passwordEncoder;

    /*
     * 配置权限相关的配置，spring 官方推荐使用 Lambda 表达式的写法
     * spring security 6.x 版本之后, and() 方法将被移除，
     * */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // 配置请求的权限
        http.authorizeHttpRequests(registry -> {
                    // 配置不需要安全拦截url
                    registry.antMatchers("/authentication/login").permitAll();
                    // 其他路径都要进行拦截
                    registry.anyRequest().authenticated();
                }
        );
        // 自定义 token 认证过滤器, 根据 token 获取用户信息后放入到 SecurityContext 上下文中, 执行顺序放在 UsernamePasswordAuthenticationFilter 之前
        http.addFilterBefore(new AuthenticationFilter(authenticationManager())
                , UsernamePasswordAuthenticationFilter.class);
        // 关闭csrf保护
        http.csrf(AbstractHttpConfigurer::disable);
        // SessionCreationPolicy.ALWAYS – 会话将始终创建（如果它不存在）。
        // SessionCreationPolicy.NEVERSpring, Security 永远不会创建 HttpSession, 但如果它已经存在, 则会使用它（可通过应用程序服务器获得）HttpSession
        // SessionCreationPolicy.IF_REQUIRED, Spring Security 只会在需要时创建 HttpSession （默认配置, 如果您不指定, Spring 安全性将使用此选项）
        // SessionCreationPolicy.STATELESS, Spring Security 永远不会创建一个HttpSession, 它永远不会使用它来获取 SecurityContext
        // 前后端分离需要设置为 STATELESS, 不创建, 否则就算令牌失效, cookie 中依然存在 JSESSIONID, 接口还是能请求
        http.sessionManagement(sessionConfigurer -> sessionConfigurer.sessionCreationPolicy(SessionCreationPolicy.STATELESS));
        return http.build();
    }

    /**
     * 配置AuthenticationManager，另一种配置方式，这个对象是spring security中用户认证的核心对象，它负责用户认证
     */
    @Bean
    public AuthenticationManager authenticationManager() {
        // 身份验证器
        DaoAuthenticationProvider daoAuthenticationProvider = new DaoAuthenticationProvider();
        // 用户详情服务
        daoAuthenticationProvider.setUserDetailsService(userService);
        // 密码编码器
        daoAuthenticationProvider.setPasswordEncoder(passwordEncoder);
        return new ProviderManager(daoAuthenticationProvider);
    }
}
````

- 在 UserServiceImpl 中注入了 PasswordEncoder，这里在 ActivitiConfiguration 配置类中声明一下实例：

`io.github.cmmplb.activiti.configuration.ActivitiConfiguration`

````java
package io.github.cmmplb.activiti.configuration;

import io.github.cmmplb.activiti.configuration.properties.ActivitiProperties;
import io.github.cmmplb.activiti.utils.MD5Util;
import org.springframework.boot.context.properties.EnableConfigurationProperties;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.crypto.password.PasswordEncoder;

/**
 * @author penglibo
 * @date 2024-11-01 15:40:52
 * @since jdk 1.8
 */

@Configuration
@EnableConfigurationProperties(ActivitiProperties.class)
public class ActivitiConfiguration {

    /**
     * 配置密码编码器，负责用户密码的加密, 放到这个配置类声明的原因是防止嵌套依赖
     * The dependencies of some of the beans in the application context form a cycle:
     * ┌─────┐
     * |  webSecurityConfigurer (field private io.github.cmmplb.activiti.service.UserService io.github.cmmplb.activiti.configuration.WebSecurityConfigurer.userService)
     * ↑     ↓
     * |  userServiceImpl (field private org.springframework.security.crypto.password.PasswordEncoder io.github.cmmplb.activiti.service.impl.UserServiceImpl.passwordEncoder)
     * └─────┘
     * 嫌麻烦的话, 可以添加允许循环依赖 spring.main.allow-circular-references = true, 然后放到 WebSecurityConfigurer 中
     */
    @Bean
    public PasswordEncoder passwordEncoder() {
        // 自定义密码编码器, 使用 MD5 加密
        return new PasswordEncoder() {
            @Override
            public String encode(CharSequence rawPassword) {
                return MD5Util.encode(rawPassword.toString());
            }

            @Override
            public boolean matches(CharSequence rawPassword, String encodedPassword) {
                return MD5Util.encode(rawPassword.toString()).equals(encodedPassword);
            }
        };
    }
}
````

- MD5Util：

`io.github.cmmplb.activiti.utils.MD5Util`

````java
package io.github.cmmplb.activiti.utils;

import java.security.MessageDigest;

/**
 * @author penglibo
 * @date 2021-08-30 15:45:15
 * @since jdk 17
 * MD5加密工具类
 */

public class MD5Util {

    // 加密算法
    public static final String MD5 = "MD5";

    /**
     * Md5加密
     * @param str 待加密字符串
     * @return md5加密串
     */
    public static String encode(String str) {
        MessageDigest md5;
        try {
            md5 = MessageDigest.getInstance(MD5);
        } catch (Exception e) {
            throw new RuntimeException(e);
        }
        char[] charArray = str.toCharArray();
        byte[] byteArray = new byte[charArray.length];

        for (int i = 0; i < charArray.length; i++) {
            byteArray[i] = (byte) charArray[i];
        }
        byte[] md5Bytes = md5.digest(byteArray);
        StringBuilder hexValue = new StringBuilder();
        for (byte md5Byte : md5Bytes) {
            int val = ((int) md5Byte) & 0xff;
            if (val < 16) {
                hexValue.append("0");
            }
            hexValue.append(Integer.toHexString(val));
        }
        // 32位加密
        return hexValue.toString();
    }
}
````

4. 登录接口以及认证信息过滤器：

- 添加一个登录的控制器，实现自定义的登录接口，AuthenticationController：

`io.github.cmmplb.activiti.controller.AuthenticationController`

````java
package io.github.cmmplb.activiti.controller;

import com.alibaba.fastjson.JSON;
import com.github.xiaoymin.knife4j.annotations.ApiOperationSupport;
import com.github.xiaoymin.knife4j.annotations.ApiSupport;
import io.github.cmmplb.activiti.constants.SecurityConstant;
import io.github.cmmplb.activiti.domain.dto.LoginDTO;
import io.github.cmmplb.activiti.handler.exection.BusinessException;
import io.github.cmmplb.activiti.result.HttpCodeEnum;
import io.github.cmmplb.activiti.result.Result;
import io.github.cmmplb.activiti.result.ResultUtil;
import io.github.cmmplb.activiti.security.UserDetails;
import io.github.cmmplb.activiti.utils.TimeExpiredPoolCacheUtil;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.Authentication;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

import java.util.UUID;

/**
 * @author penglibo
 * @date 2024-11-06 17:24:18
 * @since jdk 1.8
 */

@Api(tags = "认证管理")
@Slf4j
@ApiSupport(order = 6)
@RestController
@RequestMapping("/authentication")
public class AuthenticationController {

    @Autowired
    private AuthenticationManager authenticationManager;

    /**
     * 自定义登录，逻辑参照
     * {@link org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter}
     */
    @ApiOperation("登录")
    @ApiOperationSupport(order = 1)
    @PostMapping("/login")
    public Result<String> login(@RequestBody LoginDTO dto) {
        UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken = new UsernamePasswordAuthenticationToken(dto.getUsername(), dto.getPassword());
        Authentication authenticate = null;
        try {
            authenticate = authenticationManager.authenticate(usernamePasswordAuthenticationToken);
        } catch (BadCredentialsException e) {
            throw new BusinessException(HttpCodeEnum.BAD_CREDENTIALS);
        }
        log.info("authenticate:{}", authenticate);
        if (null == authenticate) {
            throw new BusinessException(HttpCodeEnum.BAD_CREDENTIALS);
        }
        Object principal = authenticate.getPrincipal();
        UserDetails userDetails = (UserDetails) principal;
        userDetails.setPassword("N/A");
        String authorization = UUID.randomUUID().toString();
        String prefix = SecurityConstant.AUTHORIZATION_PREFIX + authorization;
        try {
            // 这里使用内存来缓存用户信息, 需要使用其他方案缓存用户信息的话再调整, 单位毫秒值, 缓存三十分钟
            TimeExpiredPoolCacheUtil.getInstance().put(prefix, JSON.toJSONString(userDetails), 30 * 60 * 1000L);
        } catch (Exception e) {
            throw new BusinessException("设置缓存信息失败");
        }
        return ResultUtil.success(authorization);
    }
}
````

- 这里就不引入 redis 了，使用内存来做缓存，添加内存缓存工具类：

`io.github.cmmplb.activiti.utils.TimeExpiredPoolCacheUtil`

````java
package io.github.cmmplb.activiti.utils;

import java.util.LinkedList;
import java.util.List;
import java.util.Map.Entry;
import java.util.Timer;
import java.util.TimerTask;
import java.util.concurrent.ConcurrentHashMap;

/**
 * 基于内存缓存
 * @author <a href="https://blog.csdn.net/weixin_43652507/article/details/126934347">Java 使用内存缓存数据、设置失效时间</a>
 */
public class TimeExpiredPoolCacheUtil {

    // 过期时间默认10分钟
    private static final long DEFAULT_CACHED_MILLIS = 10 * 60 * 1000L;
    // 定时清理默认10分钟
    private static final long TIMER_MILLIS = 10 * 60 * 1000L;

    /**
     * 定时器定时清理过期缓存
     */
    private static final Timer TIMER = new Timer();

    /**
     * 对象池
     */
    private static ConcurrentHashMap<String, DataWrapper<?>> dataPool = null;

    /**
     * 对象单例
     */
    private static TimeExpiredPoolCacheUtil instance = null;

    private TimeExpiredPoolCacheUtil() {
        dataPool = new ConcurrentHashMap<>();
    }

    private static synchronized void syncInit() {
        if (instance == null) {
            instance = new TimeExpiredPoolCacheUtil();
            initTimer();
        }
    }

    public static TimeExpiredPoolCacheUtil getInstance() {
        if (instance == null) {
            syncInit();
        }
        return instance;
    }

    private static void initTimer() {
        TIMER.scheduleAtFixedRate(new TimerTask() {
            @Override
            public void run() {
                try {
                    clearExpiredCaches();
                } catch (Exception e) {
                    //logger.error("clearExpiredCaches error.", e);
                }
            }
        }, TIMER_MILLIS, TIMER_MILLIS);
    }

    /**
     * 缓存数据
     * @param key          key值
     * @param data         缓存数据
     * @param cachedMillis 过期时间
     * @param dataReNewer  刷新数据
     */
    @SuppressWarnings("unchecked")
    public <T> T put(String key, T data, long cachedMillis, DataReNewer<T> dataReNewer) throws Exception {
        DataWrapper<T> dataWrapper = (DataWrapper<T>) dataPool.get(key);
        if (data == null && dataReNewer != null) {
            data = dataReNewer.reNewData();
        }
        //当重新获取数据为空，直接返回不做put
        if (data == null) {
            return null;
        }
        if (dataWrapper != null) {
            //更新
            dataWrapper.update(data, cachedMillis);
        } else {
            dataWrapper = new DataWrapper<>(data, cachedMillis);
            dataPool.put(key, dataWrapper);
        }
        return data;
    }

    /**
     * 设置缓存值和时间
     */
    @SuppressWarnings("unchecked")
    public <T> T put(String key, T data, long cachedMillis) throws Exception {
        DataWrapper<T> dataWrapper = (DataWrapper<T>) dataPool.get(key);
        if (dataWrapper != null) {
            //更新
            dataWrapper.update(data, cachedMillis);
        } else {
            dataWrapper = new DataWrapper<>(data, cachedMillis);
            dataPool.put(key, dataWrapper);
        }
        return data;
    }

    /**
     * 默认构造时间的缓存数据
     */
    @Deprecated
    public <T> T put(String key, T data, DataReNewer<T> dataRenewer) throws Exception {
        return put(key, data, DEFAULT_CACHED_MILLIS, dataRenewer);
    }

    /**
     * 获取缓存
     */
    @SuppressWarnings("unchecked")
    public <T> T get(String key, long cachedMillis, DataReNewer<T> dataReNewer) throws Exception {
        DataWrapper<T> dataWrapper = (DataWrapper<T>) dataPool.get(key);
        if (dataWrapper != null && !dataWrapper.isExpired()) {
            return dataWrapper.data;
        }
        return put(key, null, cachedMillis, dataReNewer);
    }

    @SuppressWarnings("unchecked")
    public <T> T get(String key) throws Exception {
        DataWrapper<T> dataWrapper = (DataWrapper<T>) dataPool.get(key);
        if (dataWrapper != null && !dataWrapper.isExpired()) {
            return dataWrapper.data;
        }
        return null;
    }

    /**
     * 清除缓存
     */
    public void clear() {
        dataPool.clear();
    }

    /**
     * 删除指定key的value
     */
    public void remove(String key) {
        dataPool.remove(key);
    }

    /**
     * 数据封装
     */
    private static class DataWrapper<T> {
        /**
         * 数据
         */
        private T data;
        /**
         * 到期时间
         */
        private long expiredTime;
        /**
         * 缓存时间
         */
        private long cachedMillis;

        private DataWrapper(T data, long cachedMillis) {
            this.update(data, cachedMillis);
        }

        public void update(T data, long cachedMillis) {
            this.data = data;
            this.cachedMillis = cachedMillis;
            this.updateExpiredTime();
        }

        public void updateExpiredTime() {
            this.expiredTime = System.currentTimeMillis() + cachedMillis;
        }

        /**
         * 数据是否过期
         */
        public boolean isExpired() {
            if (this.expiredTime > 0) {
                return System.currentTimeMillis() > this.expiredTime;
            }
            return true;
        }
    }

    /**
     * 数据构造
     */
    public interface DataReNewer<T> {
        T reNewData();
    }

    /**
     * 清除过期的缓存
     */
    private static void clearExpiredCaches() {
        List<String> expiredKeyList = new LinkedList<>();

        for (Entry<String, DataWrapper<?>> entry : dataPool.entrySet()) {
            if (entry.getValue().isExpired()) {
                expiredKeyList.add(entry.getKey());
            }
        }
        for (String key : expiredKeyList) {
            dataPool.remove(key);
        }
    }
}
````

- 对应的常量：

`io.github.cmmplb.activiti.constants.SecurityConstant`

````java
package io.github.cmmplb.activiti.constants;

/**
 * @author penglibo
 * @date 2024-11-06 17:17:33
 * @since jdk 1.8
 */
public interface SecurityConstant {

    // 登录认证请求头
    String AUTHORIZATION = "Authorization";

    // 认证请求头缓存前缀
    String AUTHORIZATION_PREFIX = AUTHORIZATION + ":prefix:";
}
````

- 登录认证过滤器：

`io.github.cmmplb.activiti.security.filter.AuthenticationFilter`

````java
package io.github.cmmplb.activiti.security.filter;

import com.alibaba.fastjson.JSON;
import com.alibaba.fastjson.TypeReference;
import io.github.cmmplb.activiti.constants.SecurityConstant;
import io.github.cmmplb.activiti.handler.exection.BusinessException;
import io.github.cmmplb.activiti.security.UserDetails;
import io.github.cmmplb.activiti.utils.TimeExpiredPoolCacheUtil;
import org.apache.commons.lang3.StringUtils;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.www.BasicAuthenticationFilter;

import javax.servlet.FilterChain;
import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.util.concurrent.ConcurrentHashMap;

/**
 * @author penglibo
 * @date 2024-11-06 17:04:11
 * @since jdk 1.8
 * 自定义认证信息验证过滤器，根据 authorization 获取用户信息后放入到 SecurityContext 上下文中
 */
public class AuthenticationFilter extends BasicAuthenticationFilter {

    private final ConcurrentHashMap<String, UserDetails> cache = new ConcurrentHashMap<>();

    public AuthenticationFilter(AuthenticationManager authenticationManager) {
        super(authenticationManager);
    }

    @Override
    protected void doFilterInternal(HttpServletRequest request, HttpServletResponse response, FilterChain chain) throws IOException, ServletException {
        if (request.getRequestURI().contains("login")) {
            // 登录接口，直接放行
            chain.doFilter(request, response);
            return;
        }
        // 获取请求头中的token
        String authorization = request.getHeader(SecurityConstant.AUTHORIZATION);
        if (StringUtils.isEmpty(authorization)) {
            // 交给其他的过滤器处理
            chain.doFilter(request, response);
            return;
        }
        // 提取 token, 基于内存缓存
        String userDetailsJson = null;
        try {
            userDetailsJson = TimeExpiredPoolCacheUtil.getInstance().get(SecurityConstant.AUTHORIZATION_PREFIX + authorization);
        } catch (Exception e) {
            throw new BusinessException("读取缓存信息失败");
        }
        if (StringUtils.isNotEmpty(userDetailsJson)) {
            UserDetails userDetails = JSON.parseObject(userDetailsJson, new TypeReference<UserDetails>() {
            });
            UsernamePasswordAuthenticationToken usernamePasswordAuthenticationToken =
                    new UsernamePasswordAuthenticationToken(userDetails, "N/A", userDetails.getAuthorities());
            // 将用户信息放入到 SecurityContext 中
            SecurityContextHolder.getContext().setAuthentication(usernamePasswordAuthenticationToken);
        }
        chain.doFilter(request, response);
    }
}
````

- 这里把之前创建的 SecurityUtil 用上，补充获取用户信息：

`io.github.cmmplb.activiti.utils.SecurityUtil`

````java
package io.github.cmmplb.activiti.utils;

import io.github.cmmplb.activiti.handler.exection.BusinessException;
import io.github.cmmplb.activiti.result.HttpCodeEnum;
import io.github.cmmplb.activiti.security.UserDetails;
import org.springframework.security.core.Authentication;
import org.springframework.security.core.context.SecurityContextHolder;

/**
 * @author penglibo
 * @date 2024-11-01 10:25:34
 * @since jdk 1.8
 */
public class SecurityUtil {

    /**
     * 获取用户名
     */
    public static String getUserName() {
        return getUser().getUsername();
    }

    /**
     * 获取用户
     */
    public static UserDetails getUser() {
        Authentication authentication = getAuthentication();
        Object principal = authentication.getPrincipal();
        if (principal instanceof UserDetails) {
            return (UserDetails) principal;
        }
        throw new BusinessException(HttpCodeEnum.UNAUTHORIZED);
    }

    /**
     * 获取Authentication
     */
    public static Authentication getAuthentication() {
        return SecurityContextHolder.getContext().getAuthentication();
    }
}
````

- 添加一个用户控制器，返回登录用户信息：

`io.github.cmmplb.activiti.controller.UserController`

````java
package io.github.cmmplb.activiti.controller;

import com.github.xiaoymin.knife4j.annotations.ApiOperationSupport;
import com.github.xiaoymin.knife4j.annotations.ApiSupport;
import io.github.cmmplb.activiti.result.Result;
import io.github.cmmplb.activiti.result.ResultUtil;
import io.github.cmmplb.activiti.security.UserDetails;
import io.github.cmmplb.activiti.utils.SecurityUtil;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiOperation;
import lombok.extern.slf4j.Slf4j;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.RequestMapping;
import org.springframework.web.bind.annotation.RestController;

/**
 * @author penglibo
 * @date 2024-11-06 22:28:39
 * @since jdk 1.8
 */

@Api(tags = "用户管理")
@Slf4j
@ApiSupport(order = 7)
@RestController
@RequestMapping("/user")
public class UserController {

    @ApiOperation("获取用户信息")
    @GetMapping(value = "/info")
    @ApiOperationSupport(order = 1)
    public Result<UserDetails> getInfo() {
        return ResultUtil.success(SecurityUtil.getUser());
    }
}
````

5. 测试

- 重启，启动报了个错，0.0

````
An attempt was made to call a method that does not exist. The attempt was made from the following location:

    com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder.getLanguageDriver(MybatisMapperAnnotationBuilder.java:384)

The following method did not exist:

    org.apache.ibatis.session.Configuration.getLanguageDriver(Ljava/lang/Class;)Lorg/apache/ibatis/scripting/LanguageDriver;

The calling method's class, com.baomidou.mybatisplus.core.MybatisMapperAnnotationBuilder, was loaded from the following location:
...
````

官方回复：https://gitee.com/baomidou/mybatis-plus/issues/IXUDF

就是 activiti 包里的 activiti-engine 依赖 mybatis 版本太低了，使用的是 3.5.0，mybatis-plus 里的版本是 3.5.7，这里把 pom.xml
文件 activiti 排除一下 mybatis：

````xml
<!-- activiti -->
<dependency>
    <groupId>org.activiti</groupId>
    <artifactId>activiti-spring-boot-starter</artifactId>
    <version>${activiti-spring-boot-starter.version}</version>
    <exclusions>
        <exclusion>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-actuator-autoconfigure</artifactId>
        </exclusion>
        <exclusion>
            <artifactId>mybatis</artifactId>
            <groupId>org.mybatis</groupId>
        </exclusion>
    </exclusions>
</dependency>
````

重启，刷新前端页面，响应 403，并且没有返回值：

![forbidden.png](..%2Fimage%2F3.8%2Fforbidden.png)

我们先使用 postman 或者终端测试一下登录接口（下面的 shell 命令可以复制到 postman的请求栏中，会自动解析，或者粘贴到终端执行）：

````shell
curl --location 'http://localhost:20000/authentication/login' \
--header 'Content-Type: application/json' \
--data '{
    "username": "admin",
    "password": "e10adc3949ba59abbe56e057f20f883e"
}'
````

返回：

````json
{
  "code": 200,
  "msg": "操作成功",
  "data": "dc2d8327-69d6-47f7-a733-c610e1466657",
  "timestamp": 1730902378269
}
````

我们拿着这个 data 令牌凭证，拼接到请求头，key 为 Authorization，请求获取用户信息接口，当发起请求后，AuthenticationFilter
就会从请求头中获取到这个令牌，读取缓存，如果存在，则代表登录状态，设置到 SecurityContext：

````shell
curl --location 'http://localhost:20000/user/info' \
--header 'Authorization: 7db9dfe2-8934-4662-8dd4-c0e30b65e7e3'
````

返回：

````json
{
  "code": 200,
  "msg": "操作成功",
  "data": {
    "id": 1,
    "username": "admin",
    "password": "N/A",
    "name": "admin",
    "accountNonExpired": true,
    "accountNonLocked": true,
    "credentialsNonExpired": true,
    "enabled": true,
    "authorities": []
  },
  "timestamp": 1730905691181
}
````

由于是前后端分离项目，如果未登录的话，需要返回具体的状态码给前端，这里配置异常处理，一个是未登录响应的异常，另一个是权限不足的异常：

`io.github.cmmplb.activiti.security.handler.ResourceAuthenticationEntryPoint`

````java
package io.github.cmmplb.activiti.security.handler;

import com.alibaba.fastjson.JSON;
import io.github.cmmplb.activiti.result.HttpCodeEnum;
import io.github.cmmplb.activiti.result.Result;
import io.github.cmmplb.activiti.result.ResultUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.authentication.BadCredentialsException;
import org.springframework.security.authentication.InsufficientAuthenticationException;
import org.springframework.security.core.AuthenticationException;
import org.springframework.security.web.AuthenticationEntryPoint;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;
import java.io.PrintWriter;

/**
 * @author penglibo
 * @date 2024-11-06 21:44:10
 * @since jdk 1.8
 * 资源异常细节处理
 */

@Slf4j
public class ResourceAuthenticationEntryPoint implements AuthenticationEntryPoint {

    @Override
    public void commence(HttpServletRequest request, HttpServletResponse response, AuthenticationException authException) throws IOException, ServletException {
        response.setCharacterEncoding("UTF-8");
        response.setContentType("application/json");
        response.setStatus(HttpCodeEnum.UNAUTHORIZED.getCode());
        Result<String> result = ResultUtil.error(HttpCodeEnum.UNAUTHORIZED);
        if (authException != null) {
            // 设置一个data显示无效的token
            result.setData(authException.getMessage());
        }
        // 针对令牌过期
        if (authException instanceof InsufficientAuthenticationException) {
            result.setMsg(HttpCodeEnum.UNAUTHORIZED.getMessage());
        }
        // 针对凭证错误过期
        if (authException instanceof BadCredentialsException) {
            result.setMsg(HttpCodeEnum.BAD_CREDENTIALS.getMessage());
        }
        PrintWriter printWriter = response.getWriter();
        printWriter.append(JSON.toJSONString(result));
        log.info("{},{}", request.getRequestURI(), result.getMsg());
    }
}
````

`io.github.cmmplb.activiti.security.handler.AccessDeniedHandler`

````java
package io.github.cmmplb.activiti.security.handler;

import com.alibaba.fastjson.JSON;
import io.github.cmmplb.activiti.result.HttpCodeEnum;
import io.github.cmmplb.activiti.result.ResultUtil;
import lombok.extern.slf4j.Slf4j;
import org.springframework.security.access.AccessDeniedException;

import javax.servlet.ServletException;
import javax.servlet.http.HttpServletRequest;
import javax.servlet.http.HttpServletResponse;
import java.io.IOException;

/**
 * @author penglibo
 * @date 2024-11-06 21:44:39
 * @since jdk 1.8
 * 权限不足处理
 */

@Slf4j
public class AccessDeniedHandler implements org.springframework.security.web.access.AccessDeniedHandler {

    @Override
    public void handle(HttpServletRequest request, HttpServletResponse response, AccessDeniedException accessDeniedException) throws IOException, ServletException {
        log.info("禁止访问-未授权:{}", request.getRequestURI());
        response.setStatus(HttpCodeEnum.FORBIDDEN.getCode());
        response.setContentType("application/json");
        response.getWriter().write(JSON.toJSONString(ResultUtil.error(HttpCodeEnum.FORBIDDEN)));
    }
}
````

- 在 WebSecurityConfigurer 中添加该配置

`io.github.cmmplb.activiti.configuration.WebSecurityConfigurer`

````java

@Configuration
public class WebSecurityConfigurer {

    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        // ...
        // 设置异常处理器
        http.exceptionHandling(handlingConfigurer -> handlingConfigurer
                // 权限不足处理器, 当访问的资源需要权限，但是用户没有权限，就会进入这里进行处理
                .accessDeniedHandler(new AccessDeniedHandler())
                // 异常处理器, 如果不配置, 默认是 Http403ForbiddenEntryPoint 处理器, 也就是响应 403 错误
                // 因为是前后端分离, 所以需要处理响应体结构, 并将错误信息返回给前端
                .authenticationEntryPoint(new ResourceAuthenticationEntryPoint())
        );
        // ...
        return http.build();
    }
}
````

重启项目，这时刷新前端页面，就会响应具体的信息，并且有消息框了，到这 Security 登录的功能就完成了，后面再完善权限相关信息，这里先实现前端页面登录。

![noLogin.png](..%2Fimage%2F3.8%2FnoLogin.png)

### 前端

之前调用登录时，我们的密码是已经加密好的，这里前端密码输入框则需要进行 md5 加密，保证密文传输，这里先添加依赖：

## 添加依赖（两种方式执行一种就行）

**npm 方式添加**

````shell
npm install crypto-js
````

**yarn 方式添加**

````shell
yarn add crypto-js
````

- 加密方法和判断当前路由模式，以及类型声明文件

`spring-boot-activiti/web/src/utils/index.ts`

````typescript
import CryptoJS from 'crypto-js';

export const getBase = () => {
  return import.meta.env.VITE_APP_BASE_PATH;
};

export const getRoutingModeBase = () => {
  if (getRoutingMode() === 'hash') {
    // hash 模式需要添加 /# 前缀
    return getBase() + '/#';
  }
  return getBase();
};

export const getRoutingMode = () => {
  // 检查当前URL中的hash部分
  const hash = window.location.hash;

  if (hash.length > 1) {
    // 如果hash长度大于1，则表示是hash模式
    return 'hash';
  } else {
    // 否则，可能是 history 模式
    const historyApiSupported = 'pushState' in history;
    return historyApiSupported ? 'history' : 'hash';
  }
};

// 静态方法，用于对给定字符串进行MD5加密
export const md5 = (str: string): string => {
  return CryptoJS.MD5(str).toString();
}
````

- src 文件夹添加默认环境配置：`.env`

`spring-boot-activiti/web/.env`

````
# 页面标题
VITE_APP_TITLE = spring-boot-active-web

VITE_APP_BASE_API = '/api'

VITE_APP_BASE_PATH = '/vue3'
````

- 补充 .env.development 属性：

`spring-boot-activiti/web/.env.development`

````
# 开发环境配置
VITE_APP_ENV = 'development'

# 页面标题
VITE_APP_TITLE = spring-boot-active-web

# 开发环境的基础地址和代理对应
VITE_APP_BASE_API = '/api'

VITE_APP_BASE_PATH = ''

# 本地启动代理地址
VITE_APP_BASE_HOST = 'http://localhost:20000'

# 设置端口号
VITE_APP_BASE_PORT = 30000
````

`spring-boot-activiti/web/src/types/global.d.ts`

````typescript
// declare关键字用于告诉编译器某个标识符已经存在，但不需要进行类型检查
declare module '*.vue' {
  import type {DefineComponent} from 'vue';
  const component: DefineComponent<{}, {}, any>;
  const _default: DefineComponent<{}, {}, {}, any, any, any, any, {}, any, any, {}>;
  export default component;
}

// 声明全局变量
interface Window {
  $contextRoot: string;
}

// 属性栏模块包类型
declare module 'bpmn-js-properties-panel';
// 属性栏扩展属性模块包类型
declare module 'camunda-bpmn-moddle/resources/camunda';

// 小地图模块包类型
declare module 'diagram-js-minimap';

// 加密
declare module 'crypto-js' {
  export function MD5(message: string): string;
}
````

- 添加 接口 api 和类型声明

`spring-boot-activiti/web/src/api/login/authentication.ts`

````typescript
import request from '@/utils/http/axios';
import {Result} from '@/utils/http/axios/axios';

enum Api {
  BASE = '/authentication',
  LOGIN = BASE + '/login',
}

/**
 * 登录
 */
export const login = (data: LoginDTO) => {
  return request.post<Result<string>>({
    url: Api.LOGIN,
    data
  });
};
````

`spring-boot-activiti/web/src/api/login/types/authentication.d.ts`

````typescript
// declare关键字用于告诉编译器某个标识符已经存在，但不需要进行类型检查
declare interface LoginDTO {
  username: string;
  password: string;
}
````

- 添加页面

`spring-boot-activiti/web/src/views/login/index.vue`

````vue

<template>
  <div class='login-container'>
    <!-- 卡片组件 -->
    <!-- 通过shadow属性设置卡片阴影出现的时机：always、hover或never -->
    <el-card class="login-card" shadow="always">
      <div class="login-menu">
        账号密码登录
      </div>
      <div class="login-body">
        <UserLogin/>
      </div>
    </el-card>
  </div>
</template>

<script setup lang="ts">
  import UserLogin from '@/views/login/user-login.vue';
</script>

<style scoped lang='scss'>
  .login-container {
    display: flex;
    justify-content: center;
    align-items: center;
    margin-top: 210px;
    width: 100%;
    height: 100%;

    .login-card {
      width: 20%;
      //margin: 0 auto;
      padding: 10px;

      .login-menu {
        margin-bottom: 20px;
        width: 100%;
        text-align: center;
        color: #409EFF;
        font-size: 18px;
      }
    }
  }
</style>
````

- 添加凭证请求头常量：

`spring-boot-activiti/web/src/const/constant.ts`

````typescript
export default {
  // 凭证
  authorizationPrefix: 'Authorization',
};
````

- 封装一个账号密码登录的组件，如果后续还有其他方式，比如手机号验证码登录，方便引用。

`spring-boot-activiti/web/src/views/login/user-login.vue`

````vue

<template>
  <div class='user-login-container'>
    <!-- 登录表单 -->
    <Form
        ref="dataFormRef"
        :form="dataForm"
        :formItems="dataFormItems"
    >
      <template #buttons>
        <el-form-item>
          <el-button class="login-button" type="primary" :loading="loading" @click="doLogin">登录</el-button>
        </el-form-item>
      </template>
    </Form>
  </div>
</template>

<script setup lang="ts">

  import {reactive, ref} from 'vue';
  import Form from '@/components/form/index.vue';
  import {FormItem} from '@/components/form/form';
  import {useRouter} from 'vue-router';
  import {ElMessage} from 'element-plus';
  import {login} from '@/api/login/authentication.ts';
  import {md5} from '@/utils';
  import constant from '@/const/constant.ts';

  // 登陆按钮加载
  const loading = ref(false);

  // Vue 3 写法, 获取 ref 定义的组件实例
  const dataFormRef = ref();
  // 表单参数
  const dataForm = reactive<LoginDTO>({
    username: 'admin',
    password: '123456'
  });
  // 表单项
  const dataFormItems = reactive<FormItem[]>([
    {
      prop: 'username',
      prefixIcon: 'User',
      placeholder: '请输入用户名',
      rules: [
        {required: true, message: '请输入用户名', trigger: 'blur'}
      ]
    },
    {
      prop: 'password',
      prefixIcon: 'Lock',
      type: 'password',
      placeholder: '请输入密码',
      rules: [
        {required: true, message: '请输入密码', trigger: 'blur'}
      ]
    }
  ]);

  const router = useRouter();

  /**
   * 点击登录按钮
   */
  const doLogin = async () => {
    if (dataFormRef.value) {
      const valid = await dataFormRef.value.validate();
      if (valid) {
        // 密码加密
        dataForm.password = md5(dataForm.password);
        const res = await login(dataForm);
        if (res.code === 200 && res.data) {
          // 保存令牌
          localStorage.setItem(constant.authorizationPrefix, res.data);
          ElMessage({message: '登录成功', type: 'success'});
          // 跳转到首页
          await router.push({path: '/'});
        } else {
          ElMessage({message: res.msg, type: 'error'});
        }
      }
    }
  };

</script>

<style lang="scss" scoped>
  .user-login-container {

    // 登录按钮
    .login-button {
      margin-top: 10px;
      margin-left: 5%;
      width: 90%;
      height: 40px;
      border: 1px solid #409EFF;
      border-radius: 15px;
      background: none;
      font-size: 16px;
      // 字符之间的间距
      letter-spacing: 2px;
      font-weight: 300;
      color: #409EFF;
      cursor: pointer;
      transition: 0.25s;
    }

    .login-button:hover {
      background: #409EFF11;
      color: #409EFF;
    }

    // 覆盖默认样式, 设置边框圆角
    ::v-deep(.el-input__wrapper) {
      border-radius: 10px;
    }

    ::v-deep(.el-input) {
      input {
        padding: 20px 0 20px 0;
        text-indent: 5px;
      }
    }
  }
</style>
````

- 添加路由

````typescript
// 公共静态路由
const constantRoutes = [
  {
    path: '/',
    component: Layout,
    redirect: '/',
    children: [
      {
        path: '/',
        component: () => import ('@/views/home/index.vue'),
        name: '首页'
      }
    ]
  },
  {
    path: '/login',
    component: () => import ('@/views/login/index.vue'),
  }
  // ...
];
````

- 首页添加调用用户信息接口，先添加 api 和类型声明：

`spring-boot-activiti/web/src/api/sys/user.ts`

````typescript
import request from '@/utils/http/axios';
import {Result} from '@/utils/http/axios/axios';

enum Api {
  BASE = '/user',
  INFO = BASE + '/info',
}

/**
 * 根据id获取详情信息
 */
export const getInfo = () => {
  return request.get<Result<UserDetails>>({
    url: Api.INFO
  });
};
````

`spring-boot-activiti/web/src/api/sys/types/user.d.ts`

````typescript
// declare关键字用于告诉编译器某个标识符已经存在，但不需要进行类型检查
declare interface UserDetails {
  id: number;
  username: string;
  name: string;
  avatar: string;
}
````

- 修改首页，调用获取用户信息接口：

`spring-boot-activiti/web/src/views/home/index.vue`

````vue
<template>
  <div class='home-container'>
    <h1>首页</h1>
    <div>
      登录人：{{ user.name }}
    </div>
  </div>
</template>
<script setup lang="ts">
  import {getInfo} from '@/api/sys/user.ts';
  import {onMounted, reactive} from 'vue';
  import {ElMessage} from 'element-plus';

  const user = reactive<UserDetails>({
    id: 0,
    username: '',
    name: '',
    avatar: ''
  });

  // 挂载完毕后执行的回调函数
  onMounted(() => {
    getUserInfo();
  });

  const getUserInfo = async () => {
    const res = await getInfo();
    if (res.code === 200 && res.data) {
      // 把原来的值覆盖
      Object.assign(user, res.data);
    } else {
      ElMessage({message: res.msg, type: 'error'});
    }
  };

</script>
````


访问登录页，http://localhost:30000/login

账号和密码是之前添加的那几条数据，登录 admin/123456 登录成功，进入首页。

![home.png](..%2Fimage%2F3.8%2Fhome.png)

- 但点击其他列表的时候，会提示未登录

![modelList.png](..%2Fimage%2F3.8%2FmodelList.png)

- 因为还没将凭证设置到接口请求头中，在 axios
  请求拦截器和响应拦截器补充一下逻辑，如果响应未登录，则跳转到登录页，否则就将令牌放到请求头中。

`spring-boot-activiti/web/src/utils/http/axios/index.ts`

````typescript
import {router} from '@/router/index.ts';

/**
 * 请求拦截器处理
 * @param config
 */
requestInterceptor: (config: RequestConfig) => {
  const authorization = localStorage.getItem(constant.authorizationPrefix);
  if (authorization) {
    config.headers = {
      ...config.headers,
      Authorization: authorization
    };
  }
  return config;
},

  /**
   * 响应错误处理
   * @param err
   */
  responseInterceptorCatch
:
(err) => {
  console.log('响应错误处理 err:', err);
  // HTTP 状态码
  const status = err.response?.status;
  if (status === 401) {
    // 记录当前页面地址，用于登录成功回调
    console.log('router.currentRoute.value.path:', router.currentRoute.value.path);
    let refer = router.currentRoute.value.path;
    if (router.currentRoute.value.path !== '/login') {
      // 存储当前页面，用于登录成功后重定向到当前页
      localStorage.setItem(constant.redirectToPrefix, refer);
      // 跳转到首页
      router.push({path: '/login'}).then();
    }
    ElMessage({message: '登陆失效', type: 'error'});
    return Promise.reject(new Error('登陆失效'));
  }
  if (err.response?.data) {
    // 解构到 data 属性
    return err.response?.data;
  }
  return err;
}
````

- 这里把路由的对象导出：

`spring-boot-activiti/web/src/router/index.ts`

````typescript
export const router = createRouter({
  // 相同的 url, history 会触发添加到浏览器历史记录栈中, hash 不会触发, WebHistory 需要后端配合, 如果后端不配合刷新新页面会出现404, hash 不需要
  history: createWebHistory(import.meta.env.VITE_APP_BASE_PATH),
  // Hash 模式会在根目录后面拼接 /#/, 优点是刷新页面不会丢失, 缺点是URL会多一个 /#/
  // history: createWebHashHistory(import.meta.env.VITE_APP_BASE_PATH),
  // history: createMemoryHistory(import.meta.env.VITE_APP_BASE_PATH),
  routes: constantRoutes,
  strict: true,
  scrollBehavior: () => ({left: 0, top: 0})
});
````

- 接口能正常请求了：

![definitionList.png](..%2Fimage%2F3.8%2FdefinitionList.png)

- 这里添加了一个 refer，存储当前页面地址，用于登录成功回调

`spring-boot-activiti/web/src/const/constant.ts`

````typescript
export default {
  // 重定向 url
  redirectToPrefix: 'redirectTo',
};
````

`spring-boot-activiti/web/src/views/login/user-login.vue`

````typescript
/**
 * 点击登录按钮
 */
const doLogin = async () => {
    if (dataFormRef.value) {
      const valid = await dataFormRef.value.validate();
      if (valid) {
        // 密码加密
        dataForm.password = md5(dataForm.password);
        const res = await login(dataForm);
        if (res.code === 200 && res.data) {
          // 保存令牌
          localStorage.setItem(constant.authorizationPrefix, res.data);
          ElMessage({message: '登录成功', type: 'success'});
          const redirectTo = localStorage.getItem(constant.redirectToPrefix);
          if (redirectTo) {
            localStorage.removeItem(constant.redirectToPrefix);
            // 跳转到回调地址
            await router.push({path: redirectTo});
          } else {
            // 跳转到首页
            await router.push({path: '/'});
          }
        } else {
          ElMessage({message: res.msg, type: 'error'});
        }
      }
    }
  };
````

## bug 和其他事项

1. 因为添加了认证令牌，模型设计中的 activiti-modeler 需要添加凭证：

- 在 `model/activiti-modeler.vue` 页面，添加一个 $authorization：

`spring-boot-activiti/web/src/views/process/model/activiti-modeler.vue`

````vue

<template>
  <div class='activiti-modeler-container'>
    <!--    <iframe width="100%" height="100%" :src="src"></iframe>-->
    <iframe width="100%" height="100%" :src="src"></iframe>
  </div>
</template>

<script setup lang="ts">
  import {onMounted} from 'vue';
  import {useRouter} from 'vue-router';
  import constant from '@/const/constant.ts';
  import {getBase} from '@/utils';

  const router = useRouter();

  // 从路由参数中获取 modelId
  const modelId = router.currentRoute.value.query.modelId;

  // 模型编辑器地址
  const src = getBase() + '/activiti-explorer/modeler.html?modelId=' + modelId;

  onMounted(() => {
    // 通过 window 对象全局挂载全局对象或者属性, 存放在内存刷新会清空, 这并不是推荐的做法, 因为直接修改全局对象可能会导致命名冲突, 难以进行模块化管理以及不利于应用的封装与维护
    window.$contextRoot = import.meta.env.VITE_APP_BASE_API;
    window.$authorization = localStorage.getItem(constant.authorizationPrefix) + '';

  });

</script>

<style scoped lang='scss'>
  .activiti-modeler-container {
    width: 100vw;
    // 设置成 100 右侧会有一个滚动条
    height: 99vh;
  }
</style>
````

- 类型声明

`spring-boot-activiti/web/src/types/global.d.ts`

````typescript
// 声明全局变量
interface Window {
  $contextRoot: string;
  $authorization: string;
}
````

- 之后在 modeler.html 页面添加函数，使用凭证：

`spring-boot-activiti/web/public/activiti-explorer/modeler.html`

````javascript
<script>
  (
  function (open) {
  XMLHttpRequest.prototype.open = function (method, url, async, user, pass) {
    // this 指 XMLHttpRequest
    open.call(this, method, url, async, user, pass);
    this.setRequestHeader("Authorization", window.parent.$authorization);
  }
}
  )(XMLHttpRequest.prototype.open);
</script>
````

打开设计页面可以看到凭证已经设置到请求头：

![authorization.png](..%2F..%2F..%2F..%2F..%2F..%2F..%2FDownloads%2Fimages%2Fauthorization.png)

2. 之前转换模式，用的 ElMessageBox，这里对应取消和确认，但是鼠标点击弹窗外层，也会认为是取消，查看官网

https://element-plus.org/zh-CN/component/message-box.html

有一个区分取消操作与关闭操作，有些场景下，点击取消按钮与点击关闭按钮有着不同的含义。

默认情况下，当用户触发取消（点击取消按钮）和触发关闭（点击关闭按钮或遮罩层、按下 ESC 键）时，Promise 的 reject 回调和 callback
回调的参数均为 'cancel'。 如果将distinguishCancelAndClose属性设置为 true，则上述两种行为的参数分别为 'cancel' 和 'close'。

这里把之前转换模型调整一下：

`spring-boot-activiti/web/src/views/process/definition/index.vue`

````typescript
// 点击转为模型按钮
const handlerExchangeModel = async (row: ProcessDefinitionVO) => {
  // 给个默认值 3, 关闭弹框操作
  let designType: number = 3;
  await ElMessageBox.confirm('是否确认转换名称为"' + row.name + '"的流程定义为模型？', '转换模型', {
      confirmButtonText: '转换为 bpmn-js',
      cancelButtonText: '转换为 activiti-modeler',
      // 如果将 distinguishCancelAndClose 属性设置为 true, 则上述两种行为的参数分别为 'cancel' 和 'close'。
      distinguishCancelAndClose: true,
      type: 'success'
    }
  ).then(async () => {
    // 转换为 bpmn-js
    designType = 2;
  }).catch((action: Action) => {
    // 区分取消操作与关闭操作, 有些场景下，点击取消按钮与点击关闭按钮有着不同的含义
    // 默认情况下, 当用户触发取消 ( 点击取消按钮 ) 和触发关闭 ( 点击关闭按钮或遮罩层, 按下 ESC 键 ) 时. Promise 的 reject 回调和 callback 回调的参数均为 'cancel'
    if (action === 'cancel') {
      // 转换为 activiti-modeler
      designType = 1;
    } else {
      // 关闭弹框操作
      designType = 3;
      // 关闭弹框操作
      return;
    }
  });
  if (designType === 3) return;
  const res = await exchangeToModel(row.id, designType);
  if (res.code === 200 && res.data) {
    await getData();
    ElMessage({type: 'success', message: '转换成功'});
  } else {
    ElMessage({type: 'error', message: res.msg});
  }
};
````

3. 打包配置：

为了适配 WebHistory 和 WebHashHistory 模式，前面条件的 getBase 给他使用起来：

- 补充 vite.config.ts：

`spring-boot-activiti/web/vite.config.ts`

````typescript
import {ConfigEnv, defineConfig, loadEnv, UserConfigExport} from 'vite';
import vue from '@vitejs/plugin-vue';
import {resolve} from 'path';

// https://vitejs.dev/config/
export default ({mode, command}: ConfigEnv): UserConfigExport => {
  //获取当前项目路径
  const root = process.cwd();
  //  获取当前环境变量
  const env = loadEnv(mode, root);
  console.log('env:', env);
  const isBuild = command === 'build';
  console.log('isBuild:', isBuild);

// https://vitejs.dev/config/
  return defineConfig({
    // plugins是一个配置要使用插件的数组，vite插件是一个函数，所以使用时直接调用就行，不要用new 调用 。数组中也可以使用对象来添加一些属性，实现特定效果
    plugins: [
      vue()
      // createHtmlPlugin({
      //   inject: {
      //     data: {
      //       // 通过插件设置标题
      //       title: loadEnv(mode, root).VITE_APP_TITLE
      //     }
      //   }
      // })
    ],
    // ------------------------------------------------------------------------
    // 这里更改打包相对绝对路径, 使得资源可以在 Nginx 中被正确访问
    base: loadEnv(mode, root).VITE_APP_BASE_PATH,
    // 静态资源服务的文件夹。默认值为public
    // publicDir: './',
    // 模块解析时规则对象，可以在解析的时候替换指定内容，含有alias(别名)、extensions（扩展名）等属性。
    resolve: {
      alias: {
        '@': resolve(__dirname, '.', 'src')
      },
      extensions: ['.mjs', '.js', '.ts', '.jsx', '.tsx', '.json', '.vue']
    },
    //  开发服务器
    server: {
      // 服务端口
      port: Number(env.VITE_APP_BASE_PORT),
      // 启动成功后打开页面
      open: false,
      // 为开发服务器配置自定义代理规则。
      proxy:
        {
          // '/api':
          [`${loadEnv(mode, root).VITE_APP_BASE_API}`]:
            {
              // 这里代理到网关的端口
              target: loadEnv(mode, root).VITE_APP_BASE_HOST,
              changeOrigin: true,
              // 当请求地址中以"/api"开头的地址替换成空字符串
              rewrite: (h) => h.replace(/^\/api/, '')
            }
        }
    },
    // 添加一个 scss 的配置，告诉 vite 不要使用 legacy api
    css: {
      preprocessorOptions: {
        scss: {
          // or "modern", "legacy"
          api: 'modern-compiler'
        }
      }
    }
  });
}
````

