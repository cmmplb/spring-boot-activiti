# 部署管理

## 源码信息

通过 repositoryService.createDeployment() 创建 DeploymentBuilder：

`org.activiti.engine.repository.DeploymentBuilder`

````java

@Internal
public interface DeploymentBuilder {

    // 通过文件部署
    DeploymentBuilder addInputStream(String resourceName, InputStream inputStream);

    DeploymentBuilder addInputStream(String resourceName, Resource resource);

    // 指定资源文件路径部署
    DeploymentBuilder addClasspathResource(String resource);

    // 字符串部署, 即 text 为 xml 的字符串
    DeploymentBuilder addString(String resourceName, String text);

    // 字节数组部署
    DeploymentBuilder addBytes(String resourceName, byte[] bytes);

    // zip 文件部署
    DeploymentBuilder addZipInputStream(ZipInputStream zipInputStream);

    // Bpmn 模型部署
    DeploymentBuilder addBpmnModel(String resourceName, BpmnModel bpmnModel);

    // 设置资源清单, 这个 projectManifest 的使用可以在 org.activiti.engine.impl.bpmn.deployer.BpmnDeployer.setProcessDefinitionVersionsAndIds() 看到
    // 如果设置值, 则流程定义 (ProcessDefinitionEntity) 的版本号从 deployment 获取
    // 如果未设置值, 则流程定义 (ProcessDefinitionEntity) 将取最新的 + 1 : latest.getVersion() + 1
    DeploymentBuilder setProjectManifest(ProjectManifest projectManifest);

    /**
     * 如果调用, 则不会对BPMN 2.0 XSD进行XML模式验证.
     * 一般不推荐
     */
    DeploymentBuilder disableSchemaValidation();

    /**
     * 如果调用, 则不会根据流程定义验证流程定义在引擎上是否可执行.
     * 一般不推荐
     */
    DeploymentBuilder disableBpmnValidation();

    /**
     * 设置部署名称
     */
    DeploymentBuilder name(String name);

    /**
     * 设置部署分类
     */
    DeploymentBuilder category(String category);

    /**
     * 设置部署关键字
     */
    DeploymentBuilder key(String key);

    /**
     * 设置租户 id
     */
    DeploymentBuilder tenantId(String tenantId);

    /**
     * 如果已设置, 则此部署将与之前的任何部署进行比较. 这意味着每个 ( 未生成的 ) 资源都将与此部署提供的资源进行比较。
     */
    DeploymentBuilder enableDuplicateFiltering();

    /**
     * 设置此部署中包含的流程定义将被激活的日期. 这意味着所有流程定义将像往常一样部署, 但它们将被暂停开始直到给定的激活日期。
     */
    DeploymentBuilder activateProcessDefinitionsOn(Date date);

    /**
     * 添加部署属性。
     */
    DeploymentBuilder deploymentProperty(String propertyKey, Object propertyValue);

    /**
     * 部署
     */
    Deployment deploy();

}
````

- 为了方便测试 activiti 一些功能，添加一个配置类，用来设置开启以及关闭整合的这些功能（目前只用到了流程定义的部署，后续一点点的整合进去）：

`io.github.cmmplb.activiti.configuration.properties.ActivitiProperties`

````java
package io.github.cmmplb.activiti.configuration.properties;

import lombok.Data;
import org.activiti.engine.impl.persistence.entity.DeploymentEntity;
import org.springframework.boot.context.properties.ConfigurationProperties;

/**
 * @author penglibo
 * @date 2024-11-01 15:33:25
 * @since jdk 1.8
 */

@Data
@ConfigurationProperties(prefix = ActivitiProperties.PREFIX)
public class ActivitiProperties {

    /**
     * 整合模型相关信息配置
     */
    private Model model = new Model();

    /**
     * 整合部署相关信息配置
     */
    private Deployment deployment = new Deployment();

    public static final String PREFIX = "activiti";

    @Data
    public static class Model {

        /**
         * 导出模型时是否导出流程图片, 为 true 时流程文件和流程图片压缩成 zip 导出
         */
        private boolean isExportEditorSourceExtra = false;
    }

    @Data
    public static class Deployment {

        /**
         * 是否过滤重复, 默认为 false, 防止资源没有发生变化而再次执行部署方法产生的重复部署
         * - false: 每次部署 ACT_RE_DEPLOYMENT 都会新增一条部署信息, 版本号是 1, ACT_RE_PROCDEF 表会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
         * - true: 部署时会判断部署名称和流程定义文件与数据库中是否相同:
         * -- 名称相同, 流程定义文件内容相同, 数据过滤不做处理
         * -- 名称相同, 流程定义文件内容不同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号 +1 , ACT_RE_PROCDEF 表不会新增数据
         * -- 名称不同, 流程定义文件内容相同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
         * -- 名称不同, 流程定义文件内容不同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本也是 1
         */
        private boolean isAutoDeploymentEnabled = false;

        /**
         * 是否开启项目清单配置, 用来测试 ACT_RE_PROCDEF 表 APP_VERSION_ 字段和 ACT_RE_DEPLOYMENT 表 PROJECT_RELEASE_VERSION_ 字段
         * 部署相同流程时需要搭配 auto-deployment-enabled = true 一起使用, 否则模型部署和上传部署会冲突报错 ACT_RE_PROCDEF: UNIQUE KEY `ACT_UNIQ_PROCDEF`
         * **注意** 如果设置了项目资源清单版本, 则 isAutoDeploymentEnabled 的判断规则会失效, 判断逻辑改为对比数据库中项目资源清单版本号:
         * - 版本号相同则数据过滤不做处理
         * - 版本号不同则 ACT_RE_DEPLOYMENT 表新增一条记录, 版本号 +1, ACT_RE_PROCDEF 表会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
         * {@link org.activiti.engine.impl.cmd.DeployCmd#deploymentsDiffer(DeploymentEntity, DeploymentEntity)}
         * !deployment.getProjectReleaseVersion().equals(saved.getProjectReleaseVersion());
         */
        private boolean isProjectManifestEnabled = false;
    }
}
````

- 添加一个依赖，让写 yml 自定义的配置信息时有提示：

````
<!-- 配置文件处理器=》配置文件提示工具，当你在 application.yml 或者 application.properties 中输入时，会有相应的提示，方便我们写配置文件。原理是会自动给 @ConfigurationProperties 注解的类生成一个元数据信息的 json 文件，开发工具比如 idea 会自动扫描识别这个 json 然后在你写配置文件的时候给予提示。 -->
<dependency>
    <groupId>org.springframework.boot</groupId>
    <artifactId>spring-boot-configuration-processor</artifactId>
</dependency>

<!-- 同时 maven-compiler-plugin 也添加该依赖引用 -->
<path>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-configuration-processor</artifactId>
  <version>${spring-boot-dependencies.version}</version>
</path>
````

之后编译一下项目生成的元数据信息 json 文件，在项目根目录下会有 target/classes/META-INF/spring-configuration-metadata.json

- 配置文件添加对应前缀：

`spring-boot-activiti/src/main/resources/config/application-activiti.yml`

````yaml
activiti:
  # 整合模型相关信息配置
  model:
    # 导出模型时是否导出流程 svg 图片, 为 true 时流程文件和流程图片压缩 zip 导出
    export-svg: true
  # 整合部署相关信息配置
  deployment:
    # 是否过滤重复, 默认为 false, 防止资源没有发生变化而再次执行部署方法产生的重复部署
    # - false: 每次部署 ACT_RE_DEPLOYMENT 都会新增一条部署信息, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
    # - true: 部署时会判断部署名称和流程定义文件与数据库中是否相同:
    # -- 名称相同, 流程定义文件内容相同, 数据过滤不做处理
    # -- 名称相同, 流程定义文件内容不同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号 +1 , ACT_RE_PROCDEF 表不会新增数据
    # -- 名称不同, 流程定义文件内容相同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
    # -- 名称不同, 流程定义文件内容不同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本也是 1
    auto-deployment-enabled: true
    # 是否开启项目清单配置, 用来测试 ACT_RE_PROCDEF 表 APP_VERSION_ 字段和 ACT_RE_DEPLOYMENT 表 PROJECT_RELEASE_VERSION_ 字段
    # 部署相同流程时需要搭配 auto-deployment-enabled = true 一起使用, 否则模型部署和上传部署会冲突报错 ACT_RE_PROCDEF: UNIQUE KEY `ACT_UNIQ_PROCDEF`
    # **注意** 如果设置了项目资源清单版本, 则 isAutoDeploymentEnabled 的判断规则会失效, 判断逻辑改为对比数据库中项目资源清单版本号:
    # - 版本号相同则数据过滤不做处理
    # - 版本号不同则 ACT_RE_DEPLOYMENT 表新增一条记录, 版本号 +1, ACT_RE_PROCDEF 表会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
    # {@link org.activiti.engine.impl.cmd.DeployCmd#deploymentsDiffer(DeploymentEntity, DeploymentEntity)}
    # !deployment.getProjectReleaseVersion().equals(saved.getProjectReleaseVersion());
    project-manifest-enabled: true

spring:
  activiti:
  # ...
````

## 部署和导出模型

前面在 controller 层写了部署和导出模型的接口，需要在页面上添加按钮，由于 bpmn-js 保存的 xml 是没有换行的，像这样：

````java
String xml = "<?xml version=\"1.0\" encoding=\"UTF-8\"?>\n" +
        "<bpmn:definitions xmlns:xsi=\"http://www.w3.org/2001/XMLSchema-instance\" ....</bpmndi:BPMNDiagram></bpmn:definitions>";
````

导出成 xml 文件不便于查看解构（虽然看不看没啥区别，都是在设计界面上修改）

- 添加格式化 xml 工具类

  `io.github.cmmplb.activiti.utils.XmlUtil`

  ````java
  package io.github.cmmplb.activiti.utils;
  
  import org.xml.sax.InputSource;
  
  import javax.xml.parsers.DocumentBuilderFactory;
  import javax.xml.transform.OutputKeys;
  import javax.xml.transform.Transformer;
  import javax.xml.transform.TransformerFactory;
  import javax.xml.transform.dom.DOMSource;
  import javax.xml.transform.stream.StreamResult;
  import java.io.StringReader;
  import java.io.StringWriter;
  
  /**
   * @author penglibo
   * @date 2024-10-31 15:46:34
   * @since jdk 1.8
   */
  public class XmlUtil {
  
      /**
       * 格式化输出 xml
       * @param xml xml 字符串
       * @return 格式化后的 xml 字符串
       */
      public static String formatXml(String xml) throws Exception {
          DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();
          documentBuilderFactory.setCoalescing(true);
          StringWriter stringWriter = new StringWriter();
          TransformerFactory transformerFactory = TransformerFactory.newInstance();
          Transformer transformer = transformerFactory.newTransformer();
          transformer.setOutputProperty(OutputKeys.INDENT, "yes");
          transformer.setOutputProperty("{http://xml.apache.org/xslt}indent-amount", "2");
          transformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, "yes");
          transformer.transform(new DOMSource(documentBuilderFactory.newDocumentBuilder().parse(new InputSource(new StringReader(xml)))), new StreamResult(stringWriter));
          return stringWriter.toString();
      }
  }
  ````

- 补充导出模型逻辑格式化和资源清单操作：

  `io.github.cmmplb.activiti.service.impl.ModelServiceImpl.export`

  ````java
  
  @Autowired
  private DeploymentService deploymentService;
  
  @Autowired
  private ActivitiProperties activitiProperties;
  
  @Override
  public void export(String id) {
      Model model = repositoryService.getModel(id);
      if (null == model) {
          throw new BusinessException("模型信息不存在");
      }
  
      // 获取流程定义文件
      byte[] modelData = repositoryService.getModelEditorSource(id);
      if (Arrays.isNullOrEmpty(modelData)) {
          throw new BusinessException("流程模型文件不存在");
      }
      JSONObject metaInfo = JSON.parseObject(model.getMetaInfo());
      byte[] xmlBytes;
      // activiti modeler 存储的是 jsonXml, bpmn-js 存储的是 xml
      if (metaInfo.getInteger(ModelDTO.DESIGN_TYPE).equals(1)) {
          JsonNode jsonNode;
          try {
              jsonNode = objectMapper.readTree(modelData);
          } catch (IOException e) {
              throw new BusinessException("解析流程模型文件失败");
          }
          // 使用 activiti-json-converter 依赖中的转换器将 json 转换成 BpmnModel
          BpmnModel bpmnModel = (new BpmnJsonConverter()).convertToBpmnModel(jsonNode);
          // 之后将 BpmnModel 转换成 xml
          xmlBytes = (new BpmnXMLConverter()).convertToXML(bpmnModel, StandardCharsets.UTF_8.name());
      } else {
          try {
              xmlBytes = XmlUtil.formatXml(new String(modelData, StandardCharsets.UTF_8)).getBytes(StandardCharsets.UTF_8);
          } catch (Exception e) {
              log.error("格式化 xml 失败:{}", e.getMessage());
              // 格式化失败的话返回原始数据
              xmlBytes = modelData;
          }
      }
      HttpServletResponse response = ServletUtil.getResponse();
      try {
          // 导出模型时是否导出流程图片, 为 true 时流程文件和流程图片压缩成 zip 导出
          if (activitiProperties.getModel().isExportEditorSourceExtra()) {
              // 获取流程图片, activiti modeler 和 bpmn-js 图片都是将 svg 转为 png 存储
              byte[] pngData = repositoryService.getModelEditorSourceExtra(id);
              // 用于部署上传流程文件测试 ACT_RE_PROCDEF 表 DGRM_RESOURCE_NAME_ 字段
              String filename = model.getName() + ".zip";
              response.setContentType("application/octet-stream");
              response.setHeader("Content-Disposition", "attachment;filename=" + new String(URLEncoder.encode(filename, StandardCharsets.UTF_8.name()).getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8));
              ZipOutputStream zipOutputStream = new ZipOutputStream(response.getOutputStream(), StandardCharsets.UTF_8);
              // 压缩流程文件, 通过流程文件需要满足这个后缀条件: "bpmn20.xml", "bpmn"
              FileUtil.toZip(zipOutputStream, model.getName() + ".bpmn20.xml", new ByteArrayInputStream(xmlBytes));
              // 压缩流程 svg 图片, 图片需要满足: "png", "jpg", "gif", "svg"
              FileUtil.toZip(zipOutputStream, model.getName() + ".png", new ByteArrayInputStream(pngData));
          } else {
              ByteArrayInputStream in = new ByteArrayInputStream(xmlBytes);
              String filename = model.getName() + ".bpmn20.xml";
              response.setContentType("application/xml");
              response.setHeader("Content-Disposition", "attachment;filename=" + new String(URLEncoder.encode(filename, StandardCharsets.UTF_8.name()).getBytes(StandardCharsets.UTF_8), StandardCharsets.UTF_8));
              IOUtils.copy(in, response.getOutputStream());
              // 可以实时将部分结果发送给客户端, 而不是等待整个操作完成后再发送‌
              response.flushBuffer();
          }
      } catch (IOException e) {
          throw new BusinessException("导出流程模型文件失败");
      }
  }
  
  @Override
  public boolean deployment(String id) {
      Model model = repositoryService.getModel(id);
      if (null == model) {
          throw new BusinessException("模型信息不存在");
      }
      // 构建部署对象
      DeploymentBuilder deploymentBuilder = repositoryService.createDeployment();
  
      // 获取流程定义文件
      byte[] modelData = repositoryService.getModelEditorSource(id);
      JSONObject metaInfo = JSON.parseObject(model.getMetaInfo());
      String resourceName = model.getKey() + ".bpmn20.xml";
      // 设计类型:1-activiti modeler;2-bpmn-js;
      if (metaInfo.getInteger(ModelDTO.DESIGN_TYPE).equals(1)) {
          JsonNode jsonNode;
          try {
              jsonNode = objectMapper.readTree(modelData);
          } catch (IOException e) {
              throw new BusinessException("解析流程模型文件失败");
          }
          // 基于 BpmnModel 部署模型
          BpmnModel bpmnModel = (new BpmnJsonConverter()).convertToBpmnModel(jsonNode);
          // 前面基础是基于 .addClasspathResource("processes/test.bpmn20.xml") 来部署的
          deploymentBuilder.addBpmnModel(resourceName, bpmnModel);
      } else {
          // 基于 xml 部署模型
          deploymentBuilder.addBytes(resourceName, modelData);
      }
      // 获取流程设计图片
      byte[] modelEditorSourceExtra = repositoryService.getModelEditorSourceExtra(id);
      if (!Arrays.isNullOrEmpty(modelEditorSourceExtra)) {
          // 对应数据库 ACT_RE_PROCDEF 表 DGRM_RESOURCE_NAME_ 字段
          deploymentBuilder.addInputStream(model.getKey() + ".png", new ByteArrayInputStream(modelEditorSourceExtra));
      }
      if (activitiProperties.getDeployment().isProjectManifestEnabled()) {
          // =================设置资源清单=================
          // 为了测试表中字段, 使用项目资源清单对应 PROJECT_RELEASE_VERSION_, 这个项目版本会保存在 ACT_RE_DEPLOYMENT 表的 PROJECT_RELEASE_VERSION_ 字段中, 同时更新 ACT_RE_PROCDEF 表的 APP_VERSION_ 字段
          // projectManifest 的使用可以在 org.activiti.engine.impl.bpmn.deployer.BpmnDeployer.setProcessDefinitionVersionsAndIds() 看到
          // - 如果设置资源清单, 则流程定义 (ProcessDefinitionEntity) 的版本号从 deployment 获取
          // - 如果未设置, 则流程定义将取 (ProcessDefinitionEntity) 最新版本 + 1, 即: latest.getVersion() + 1
          List<Deployment> list = repositoryService.createDeploymentQuery().deploymentName(model.getName()).orderByDeploymenTime().desc().list();
          // **注意** 如果设置了项目资源清单版本, 则 isAutoDeploymentEnabled 的判断规则会失效, 判断逻辑改为对比数据库中项目资源清单版本号:
          // - 版本号相同则数据过滤不做处理
          // - 版本号不同则 ACT_RE_DEPLOYMENT 表新增一条记录, 版本号 +1, ACT_RE_PROCDEF 表会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
          // org.activiti.engine.impl.cmd.DeployCmd.deploymentsDiffer():
          // !deployment.getProjectReleaseVersion().equals(saved.getProjectReleaseVersion());
  
          // 这里我们如果存在相同部署名称, 可以把版本号提取出来, 赋值给项目资源清单属性, 从列表中取第一个获取版本号
          String version = CollectionUtils.isEmpty(list) ? "1" : String.valueOf((list.get(0).getVersion() + 1));
          deploymentBuilder.setProjectManifest(deploymentService.buildProjectManifest(model.getName(), metaInfo.getString(ModelDataJsonConstants.MODEL_DESCRIPTION), version));
      }
      // 这里有个问题, 就是设置资源清单的话, deploymentBuilder 并没有设置 version 的方法, 第二次再部署的话, 会报错 act_re_procdef: UNIQUE KEY `ACT_UNIQ_PROCDEF` (`KEY_`,`VERSION_`,`TENANT_ID_`)
      // 原因就是上面说的设置资源清单版本号, 流程定义从 deployment 获取, 而 deployment 版本不会更新, 就会导致添加流程定义数据唯一索引重复: UNIQUE KEY
      // 所以这里我们使用 enableDuplicateFiltering(), 开启之后 deployment 会查询是否存在相同名称的部署信息:
      // 是否过滤重复, 默认为 false, 防止资源没有发生变化而再次执行部署方法产生的重复部署
      if (activitiProperties.getDeployment().isAutoDeploymentEnabled()) {
          // - false: 每次部署 ACT_RE_DEPLOYMENT 都会新增一条部署信息, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据
          // - true: 部署时会判断部署名称和流程定义文件与数据库中是否相同:
          // * -- 名称相同, 流程定义文件内容相同, 数据过滤不做处理
          // * -- 名称相同, 流程定义文件内容不同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号 +1 , ACT_RE_PROCDEF 表不会新增数据
          // * -- 名称不同, 流程定义文件内容相同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
          // * -- 名称不同, 流程定义文件内容不同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本也是 1
          deploymentBuilder.enableDuplicateFiltering();
          // 这里有点绕，注释有点啰嗦
      }
      deploymentBuilder.name(model.getName()).category(model.getCategory()).key(model.getKey());
      try {
          // 通过流程文件需要满足这个后缀条件: "bpmn20.xml", "bpmn"
          // 图片需要满足: "png", "jpg", "gif", "svg"
          // 对应源码 org.activiti.engine.impl.bpmn.deployer.ResourceNameUtil
          Deployment deploy = deploymentBuilder.deploy();
          model.setDeploymentId(deploy.getId());
      } catch (PersistenceException p) {
          // 由上面的 setProjectManifest 衍生问题: 通过模型部署后, 再来使用上传文件部署会报错 act_re_procdef: UNIQUE KEY `ACT_UNIQ_PROCDEF`, 反过来亦是如此
          // 原因是上传模型部署使用的是流程文件节点 process id 赋值给 KEY_ 字段, 然后上面设置了 projectManifest, 流程定义 (ProcessDefinitionEntity) 的版本号从 deployment 获取
          // 就出现 ACT_RE_PROCDEF 表 KEY_ 和 版本号相同的情况, 这里解决办法就是规定上传的文件名称和模型名称相同才行, 否则代表流程定义信息已存在
          if (p.getCause() instanceof SQLIntegrityConstraintViolationException && p.getCause().getMessage().contains("Duplicate entry")) {
              throw new BusinessException("流程定义信息已存在, 若要更新版本, 请将上传的部署文件名称和模型名称设为相同");
          }
      } catch (Exception e) {
          throw new BusinessException("流程图不合规范，请重新设计");
      }
      // 更新模型信息部署 id 字段
      repositoryService.saveModel(model);
      return true;
  }
  ````

- 前端 api 接口和导出工具类：

  `spring-boot-activiti/web/src/api/process/model.ts`

  ````typescript
  /**
   * 导出流程模型文件
   */
  export const exportModel = (id: string) => {
      return request.get<AxiosResponse>({
        url: '/model/export/' + id,
        // 重要! 设置响应类型为 blob 或 arraybuffer
        responseType: 'blob'
      });
    };
  
  /**
   * 部署模型
   */
  export const deployment = (id: string) => {
    return request.post<Result<boolean>>({
      url: '/model/deploy/' + id
    });
  };
  ````

  `spring-boot-activiti/web/src/utils/index.ts`

  ````typescript
  // 下载文件
  import {AxiosResponse} from 'axios';
  import {ElMessage} from 'element-plus';
  
  export const downFile = (response: AxiosResponse<any, any>, fileName: string) => {
    // 创建一个新的 Blob 对象，我这里在 interceptors.responseInterceptor 中判断没有解构, 所以文件流信息在 data 里面
    const blob = new Blob([response.data]);
    const reader = new FileReader();
    reader.readAsText(blob, 'UTF-8');
    // 监听文件读取结束后事件
    reader.onloadend = () => {
      // 读取文件内容
      const content = String(reader.result);
      // 出现了错误
      if ('{' === content.substring(0, 1)) {
        // {"msg":error}
        const parse = JSON.parse(content);
        ElMessage({type: 'error', message: parse.msg});
      } else {
        // 获取响应头
        let headers = response.headers;
        const blob = new Blob([response.data], {
          // 注意这里的是小写 content-type
          type: headers['content-type']
        });
        // 如果后端设置了文件名称
        const nameKey = (Object.keys(response.headers) || []).find((ele) => {
          return ele.toLowerCase() == 'content-disposition';
        });
        if (nameKey) {
          // content-disposition: "attachment;filename=leave-bpmn-js.bpmn20.xml"
          fileName = response.headers[nameKey].split('=')[1];
          fileName = decodeURIComponent(fileName);
        }
        // 创建一个指向新 Blob 对象的 URL
        let url = URL.createObjectURL(blob);
        // 创建一个 a 标签用于下载，隐藏，设置 href 属性，触发点击方法
        let link = document.createElement('a');
        link.style.display = 'none';
        link.href = url;
        // 设置下载文件名
        link.setAttribute('download', fileName);
        document.body.appendChild(link);
        // 触发下载
        link.click();
        // 清理并移除元素和对象URL
        document.body.removeChild(link);
        window.URL.revokeObjectURL(url);
      }
    };
  };
  ````

**注意，之前在前端 axios 响应拦截器中，对 data 解构了一层，这里需要加个判断，下载请求不解构，因为要获取响应体中的 headers**：

`spring-boot-activiti/web/src/utils/http/axios/index.ts`

````typescript
  /**
 * 响应拦截器处理
 * @param res
 */
responseInterceptor: (res) => {
  console.log('响应成功的拦截');
  if (res.headers) {
    // 注意这里的是小写 content-type
    const contentType = res.headers['content-type'];
    // 处理其他类型
    if (contentType === 'application/force-download' || contentType === 'application/xml' || contentType === 'application/octet-stream') {
      // 这里不解构
      return res;
    }
  }
  // 解构一层data
  return res.data;
}

/**
 * 响应错误处理
 * @param err
 */
responseInterceptorCatch: (err) => {
  if (err.response?.data) {
    // 解构到 data 属性
    return err.response?.data;
  }
  return err;
}
````

- 前端页面模型列表表格操作中添加部署和导出按钮：

  ````vue
  
  <template>
    <!-- ... -->
    <el-button
        icon="Edit"
        @click="handlerDeployment(scope.row)"
        text
        style="color: rgb(87,163,26)"
    >部署
    </el-button
    >
    <el-button
        icon="Edit"
        @click="handlerExport(scope.row)"
        text
        style="color: rgb(221,0,255)"
    >导出
    </el-button
    >
  </template>
  
  <script setup lang="ts">
    import {ElMessage, ElMessageBox} from 'element-plus';
    import {AxiosResponse} from 'axios';
    import {downFile} from '@/utils';
  
    // 点击部署按钮
    const handlerDeployment = (row: ModelVO) => {
      ElMessageBox.confirm('是否确认部署名称为"' + row.name + '"的模型？', '部署', {
            confirmButtonText: '确定',
            cancelButtonText: '取消',
            type: 'success'
          }
      ).then(async () => {
        const res = await deployment(row.id);
        console.log('res:', res);
        if (res.code === 200 && res.data) {
          await getData();
          ElMessage({type: 'success', message: '部署成功'});
        } else {
          ElMessage({type: 'error', message: res.msg});
        }
      }).catch(() => {
        // 取消部署
      });
    };
  
    // 点击导出按钮
    const handlerExport = (row: ModelVO) => {
      exportModel(row.id).then((response: AxiosResponse) => {
        downFile(response, row.key + '.bpmn20.xml');
      });
    };
  </script>
  ````

![deployment.png](..%2Fimage%2F3.6%2Fdeployment.png)

未格式化的 bpmn-js 文件：

![unFormat.png](..%2Fimage%2F3.6%2FunFormat.png)

格式化之后的 bpmn-js 文件：

![format.png](..%2Fimage%2F3.6%2Fformat.png)

## 部署管理相关接口

- DeploymentVO：

  `io.github.cmmplb.activiti.domain.vo.DeploymentVO`

  ````java
  package io.github.cmmplb.activiti.domain.vo;
  
  import com.fasterxml.jackson.annotation.JsonFormat;
  import io.swagger.annotations.ApiModel;
  import io.swagger.annotations.ApiModelProperty;
  import lombok.Data;
  
  import java.util.Date;
  
  /**
   * @author penglibo
   * @date 2024-10-31 16:39:24
   * @since jdk 1.8
   */
  
  
  @Data
  @ApiModel(value = "DeploymentVO", description = "流程部署返回参数")
  public class DeploymentVO {
  
      @ApiModelProperty(value = "主键", example = "1")
      private String id;
  
      @ApiModelProperty(value = "部署名称", example = "请假模型")
      private String name;
  
      @ApiModelProperty(value = "类型", example = "leave-bpmn-js")
      private String category;
  
      @ApiModelProperty(value = "关键字", example = "leave")
      private String key;
  
      @ApiModelProperty(value = "部署时间", example = "2023-11-11 12:12:11")
      @JsonFormat(timezone = "GMT+8", pattern = "yyyy-MM-dd HH:mm:ss")
      private Date deploymentTime;
  
      @ApiModelProperty(value = "版本号, 从 1 开始", example = "1")
      private Integer version;
  }
  ````

- DeploymentConvert：

  `io.github.cmmplb.activiti.convert.DeploymentConvert`
  ````java
  package io.github.cmmplb.activiti.convert;
  
  import io.github.cmmplb.activiti.domain.vo.DeploymentVO;
  import org.activiti.engine.repository.Deployment;
  import org.mapstruct.Mapper;
  
  /**
   * @author penglibo
   * @date 2022-08-03 16:56:25
   * @since jdk 1.8
   */
  
  @Mapper
  public interface DeploymentConvert extends Converter<Deployment, DeploymentVO> {
  
  }
  ````

- DeploymentController：

  `io.github.cmmplb.activiti.controller.DeploymentController`

  ````java
  package io.github.cmmplb.activiti.controller;
  
  import com.github.xiaoymin.knife4j.annotations.ApiOperationSupport;
  import com.github.xiaoymin.knife4j.annotations.ApiSupport;
  import io.github.cmmplb.activiti.beans.PageResult;
  import io.github.cmmplb.activiti.beans.QueryPageBean;
  import io.github.cmmplb.activiti.domain.vo.DeploymentVO;
  import io.github.cmmplb.activiti.result.Result;
  import io.github.cmmplb.activiti.result.ResultUtil;
  import io.github.cmmplb.activiti.service.DeploymentService;
  import io.swagger.annotations.Api;
  import io.swagger.annotations.ApiOperation;
  import lombok.extern.slf4j.Slf4j;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.web.bind.annotation.*;
  import org.springframework.web.multipart.MultipartFile;
  
  /**
   * @author penglibo
   * @date 2024-10-31 16:12:00
   * @since jdk 1.8
   */
  
  @Api(tags = "部署管理")
  @Slf4j
  @RestController
  @ApiSupport(order = 4)
  @RequestMapping("/deployment")
  public class DeploymentController {
  
      @Autowired
      private DeploymentService deploymentService;
  
      @ApiOperation("分页条件查询列表")
      @PostMapping(value = "/paged")
      @ApiOperationSupport(order = 1)
      public Result<PageResult<DeploymentVO>> getByPaged(@RequestBody QueryPageBean queryPageBean) {
          return ResultUtil.success(deploymentService.getByPaged(queryPageBean));
      }
  
      @ApiOperation("上传部署流程文件")
      @PostMapping(value = "/upload")
      @ApiOperationSupport(order = 2)
      public Result<Boolean> upload(@RequestPart(value = "files") MultipartFile[] files) {
          return ResultUtil.success(deploymentService.upload(files));
      }
  
      @ApiOperation("删除")
      @DeleteMapping(value = "/{id}")
      @ApiOperationSupport(order = 3, ignoreParameters = {"id"})
      public Result<Boolean> removeById(@PathVariable(value = "id") String id) {
          return ResultUtil.success(deploymentService.removeById(id));
      }
  }
  ````

- DeploymentService：

  `io.github.cmmplb.activiti.service.DeploymentService`

  ````java
  package io.github.cmmplb.activiti.service;
  
  import io.github.cmmplb.activiti.beans.PageResult;
  import io.github.cmmplb.activiti.beans.QueryPageBean;
  import io.github.cmmplb.activiti.domain.vo.DeploymentVO;
  import org.springframework.web.multipart.MultipartFile;
  
  /**
   * @author penglibo
   * @date 2024-10-31 16:39:04
   * @since jdk 1.8
   */
  public interface DeploymentService {
  
      PageResult<DeploymentVO> getByPaged(QueryPageBean queryPageBean);
  
      boolean upload(MultipartFile[] files);
  
      boolean removeById(String id);
  
      ProjectManifest buildProjectManifest(String name, String description, String version);
  }
  ````

- DeploymentServiceImpl：

  `com.cmmplb.activiti.service.impl.DeployServiceImpl`

  ````java
  package io.github.cmmplb.activiti.service.impl;
  
  import io.github.cmmplb.activiti.beans.PageResult;
  import io.github.cmmplb.activiti.beans.QueryPageBean;
  import io.github.cmmplb.activiti.configuration.properties.ActivitiProperties;
  import io.github.cmmplb.activiti.convert.DeploymentConvert;
  import io.github.cmmplb.activiti.domain.vo.DeploymentVO;
  import io.github.cmmplb.activiti.handler.exection.BusinessException;
  import io.github.cmmplb.activiti.service.DeploymentService;
  import io.github.cmmplb.activiti.utils.ConverterUtil;
  import io.github.cmmplb.activiti.utils.DateUtil;
  import io.github.cmmplb.activiti.utils.SecurityUtil;
  import lombok.extern.slf4j.Slf4j;
  import org.activiti.core.common.project.model.ProjectManifest;
  import org.activiti.engine.RepositoryService;
  import org.activiti.engine.repository.Deployment;
  import org.activiti.engine.repository.DeploymentBuilder;
  import org.activiti.engine.repository.DeploymentQuery;
  import org.apache.commons.lang3.StringUtils;
  import org.apache.ibatis.exceptions.PersistenceException;
  import org.springframework.beans.factory.annotation.Autowired;
  import org.springframework.stereotype.Service;
  import org.springframework.util.CollectionUtils;
  import org.springframework.web.multipart.MultipartFile;
  
  import java.io.InputStream;
  import java.sql.SQLIntegrityConstraintViolationException;
  import java.util.ArrayList;
  import java.util.List;
  import java.util.UUID;
  import java.util.stream.Collectors;
  import java.util.zip.ZipInputStream;
  
  /**
   * @author penglibo
   * @date 2024-10-31 16:39:09
   * @since jdk 1.8
   */
  
  @Slf4j
  @Service
  public class DeploymentServiceImpl implements DeploymentService {
  
      // 管理和控制流程定义的服务接口，包括部署、查询和删除流程定义等功能；
      @Autowired
      private RepositoryService repositoryService;
  
      @Autowired
      private ActivitiProperties activitiProperties;
  
      @Override
      public PageResult<DeploymentVO> getByPaged(QueryPageBean queryPageBean) {
          DeploymentQuery query = repositoryService.createDeploymentQuery();
          if (StringUtils.isNotEmpty(queryPageBean.getKeywords())) {
              // 根据模型名称模糊查询
              query.deploymentNameLike(queryPageBean.getKeywords());
          }
          List<DeploymentVO> res = new ArrayList<>();
          // count 查询总数
          long total = query.count();
          if (total > 0) {
              query.orderByDeploymenTime().desc();
              // 根据部署时间倒序, 分页查询
              List<Deployment> list = query.orderByDeploymenTime().desc().listPage(queryPageBean.getStart(), queryPageBean.getSize());
              // .stream().map() jdk 8 语法
              return new PageResult<>(total, list.stream().map(deployment -> ConverterUtil.convert(DeploymentConvert.class, deployment)
              ).collect(Collectors.toList()));
          }
          return new PageResult<>(total, res);
      }
  
      @Override
      public boolean upload(MultipartFile[] files) {
          for (MultipartFile file : files) {
              String fileName = file.getOriginalFilename();
              if (StringUtils.isBlank(fileName)) {
                  throw new BusinessException("文件格式错误");
              }
              String prefixName = fileName;
              String suffixName = fileName;
              if (fileName.lastIndexOf(".") != -1) {
                  // 文件前缀名
                  prefixName = fileName.substring(0, fileName.indexOf("."));
                  // 文件后缀名
                  suffixName = fileName.substring(fileName.lastIndexOf("."));
              }
              if (!".zip".equals(suffixName) && !".bpmn".equals(suffixName) && !".xml".equals(suffixName)) {
                  throw new BusinessException("文件格式错误");
              }
              try {
                  String uploadDeployment = "UPLOAD-DEPLOYMENT-";
                  InputStream is = file.getInputStream();
                  DeploymentBuilder deploymentBuilder = repositoryService.createDeployment()
                          .name(prefixName)
                          // 自定义关键字
                          .key(uploadDeployment + UUID.randomUUID())
                          .category("http://www.activiti.org/processdef");
                  if (activitiProperties.getDeployment().isProjectManifestEnabled()) {
                      // =================设置资源清单=================
                      // 为了测试表中字段, 使用项目资源清单对应 PROJECT_RELEASE_VERSION_, 这个项目版本会保存在 ACT_RE_DEPLOYMENT 表的 PROJECT_RELEASE_VERSION_ 字段中, 同时更新 ACT_RE_PROCDEF 表的 APP_VERSION_ 字段
                      // projectManifest 的使用可以在 org.activiti.engine.impl.bpmn.deployer.BpmnDeployer.setProcessDefinitionVersionsAndIds() 看到
                      // - 如果设置资源清单, 则流程定义 (ProcessDefinitionEntity) 的版本号从 deployment 获取
                      // - 如果未设置, 则流程定义将取 (ProcessDefinitionEntity) 最新版本 + 1, 即: latest.getVersion() + 1
                      List<Deployment> list = repositoryService.createDeploymentQuery().deploymentName(prefixName).orderByDeploymenTime().desc().list();
                      // **注意** 如果设置了项目资源清单版本, 则 isAutoDeploymentEnabled 的判断规则会失效, 判断逻辑改为对比数据库中项目资源清单版本号:
                      // - 版本号相同则数据过滤不做处理
                      // - 版本号不同则 ACT_RE_DEPLOYMENT 表新增一条记录, 版本号 +1, ACT_RE_PROCDEF 表会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
                      // org.activiti.engine.impl.cmd.DeployCmd.deploymentsDiffer():
                      // !deployment.getProjectReleaseVersion().equals(saved.getProjectReleaseVersion());
  
                      // 这里我们如果存在相同部署名称, 可以把版本号提取出来, 赋值给项目资源清单属性, 从列表中取第一个获取版本号
                      String version = CollectionUtils.isEmpty(list) ? "1" : String.valueOf((list.get(0).getVersion() + 1));
                      deploymentBuilder.setProjectManifest(buildProjectManifest(prefixName, uploadDeployment, version));
                  }
                  // 这里有个问题, 就是设置资源清单的话, deploymentBuilder 并没有设置 version 的方法, 第二次再部署的话, 会报错 act_re_procdef: UNIQUE KEY `ACT_UNIQ_PROCDEF` (`KEY_`,`VERSION_`,`TENANT_ID_`)
                  // 原因就是上面说的设置资源清单版本号, 流程定义从 deployment 获取, 而 deployment 版本不会更新, 就会导致添加流程定义数据唯一索引重复: UNIQUE KEY
                  // 开启 isAutoDeploymentEnabled 之后 deployment 会查询是否存在相同名称的部署信息:
                  // 是否过滤重复, 默认为 false, 防止资源没有发生变化而再次执行部署方法产生的重复部署
                  if (activitiProperties.getDeployment().isAutoDeploymentEnabled()) {
                      // - false: 每次部署 ACT_RE_DEPLOYMENT 都会新增一条部署信息, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据
                      // - true: 部署时会判断部署名称和流程定义文件与数据库中是否相同:
                      // * -- 名称相同, 流程定义文件内容相同, 数据过滤不做处理
                      // * -- 名称相同, 流程定义文件内容不同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号 +1 , ACT_RE_PROCDEF 表不会新增数据
                      // * -- 名称不同, 流程定义文件内容相同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本 +1
                      // * -- 名称不同, 流程定义文件内容不同, ACT_RE_DEPLOYMENT 表新增一条记录, 版本号是 1, ACT_RE_PROCDEF 会根据部署时的模型文件数量新增对应 n 条数据, 同时版本也是 1
                      deploymentBuilder.enableDuplicateFiltering();
                      // 这里有点绕，注释有点啰嗦
                  }
                  if (".zip".equals(suffixName)) {
                      deploymentBuilder.addZipInputStream(new ZipInputStream(is));
                  } else {
                      deploymentBuilder.addInputStream(fileName, is);
                  }
                  // 通过流程文件需要满足这个后缀条件: "bpmn20.xml", "bpmn"
                  // 图片需要满足: "png", "jpg", "gif", "svg"
                  // 对应源码 org.activiti.engine.impl.bpmn.deployer.ResourceNameUtil
                  deploymentBuilder.deploy();
              } catch (PersistenceException p) {
                  // 由上面的 setProjectManifest 衍生问题: 通过模型部署后, 再来使用上传文件部署会报错 act_re_procdef: UNIQUE KEY `ACT_UNIQ_PROCDEF`, 反过来亦是如此
                  // 原因是上传模型部署使用的是流程文件节点 process id 赋值给 KEY_ 字段, 然后上面设置了 projectManifest, 流程定义 (ProcessDefinitionEntity) 的版本号从 deployment 获取
                  // 就出现 ACT_RE_PROCDEF 表 KEY_ 和 版本号相同的情况, 这里解决办法就是规定上传的文件名称和模型名称相同才行, 否则代表流程定义信息已存在
                  if (p.getCause() instanceof SQLIntegrityConstraintViolationException && p.getCause().getMessage().contains("Duplicate entry")) {
                      throw new BusinessException("流程定义信息已存在, 若要更新版本, 请将上传的部署文件名称和模型名称设为相同");
                  }
              } catch (Exception e) {
                  log.error("部署失败", e);
                  throw new BusinessException("部署失败");
              }
          }
          return true;
      }
  
      @Override
      public boolean removeById(String id) {
          // 删除部署，如果有同时在运行的流程则会抛出异常
          // repositoryService.deleteDeployment(id);
          // 删除部署，同时及联删除关联的流程
          repositoryService.deleteDeployment(id, true);
          return true;
      }
  
      // 构建项目清单
      @Override
      public ProjectManifest buildProjectManifest(String name, String description, String version) {
          ProjectManifest manifest = new ProjectManifest();
          manifest.setId(UUID.randomUUID().toString());
          manifest.setCreatedBy(SecurityUtil.getUserName());
          manifest.setCreationDate(DateUtil.getCurrentDateTimeString());
          manifest.setLastModifiedBy(SecurityUtil.getUserName());
          manifest.setLastModifiedDate(DateUtil.getCurrentDateTimeString());
          manifest.setName(name);
          manifest.setDescription(description);
          manifest.setVersion(version);
          return manifest;
      }
  }
  
  ````

- 工具类：

`io.github.cmmplb.activiti.utils.DateUtil`

````java
package io.github.cmmplb.activiti.utils;

import lombok.extern.slf4j.Slf4j;

import java.text.DateFormat;
import java.text.ParseException;
import java.text.SimpleDateFormat;
import java.util.*;

/**
 * @author penglibo
 * @date 2024-11-01 10:26:43
 * @since jdk 1.8
 */

@Slf4j
public class DateUtil {

    public final static String FORMAT_DATE_YYYY_MM_DD_HH_MM_SS = "yyyy-MM-dd HH:mm:ss";

    /**
     * 锁对象
     */
    private static final Object LOCK_OBJ = new Object();
    private static final Map<String, ThreadLocal<DateFormat>> SDF_MAP = new HashMap<>();

    /**
     * 返回一个ThreadLocal的sdf,每个线程只会new一次sdf
     * @param pattern 日期格式
     */
    private static DateFormat getSdf(final String pattern) {
        ThreadLocal<DateFormat> tl = SDF_MAP.get(pattern);
        // 此处的双重判断和同步是为了防止sdfMap这个单例被多次put重复的sdf
        if (tl == null) {
            synchronized (LOCK_OBJ) {
                tl = SDF_MAP.get(pattern);
                if (tl == null) {
                    // 只有Map中还没有这个pattern的sdf才会生成新的sdf并放入map
                    // 这里是关键,使用ThreadLocal<SimpleDateFormat>替代原来直接new SimpleDateFormat
                    tl = ThreadLocal.withInitial(() -> new SimpleDateFormat(pattern, Locale.CHINA));
                    SDF_MAP.put(pattern, tl);
                }
            }
        }
        return tl.get();
    }

    /**
     * 是用ThreadLocal<SimpleDateFormat>来获取SimpleDateFormat,这样每个线程只会有一个SimpleDateFormat
     * @param date    日期
     * @param pattern 日期格式
     * @return 字符串日期
     */
    public static String formatDate(Date date, String pattern) {
        return getSdf(pattern).format(date);
    }

    public static Date parseToDate(String dateStr, String pattern) {
        try {
            return getSdf(pattern).parse(dateStr);
        } catch (ParseException e) {
            log.error("日期转换失败", e);
        }
        return null;
    }

    /**
     * 获取当前日期
     * @return 当前日期
     */
    public static Date getCurrentDateTime() {
        return Calendar.getInstance().getTime();
    }

    /**
     * 获取当前日期字符串
     * @return 当前日期字符串
     */
    public static String getCurrentDateTimeString() {
        return formatDate(getCurrentDateTime(), FORMAT_DATE_YYYY_MM_DD_HH_MM_SS);
    }
}

````

`io.github.cmmplb.activiti.utils.SecurityUtil`

````java
package io.github.cmmplb.activiti.utils;

/**
 * @author penglibo
 * @date 2024-11-01 10:25:34
 * @since jdk 1.8
 */
public class SecurityUtil {

    /**
     * 先写死, 等后面整合后台用户
     */
    public static String getUserName() {
        return "admin";
    }
}
````

- FileUtil：

`io.github.cmmplb.activiti.utils.FileUtil`

````java
package io.github.cmmplb.activiti.utils;

import io.github.cmmplb.activiti.handler.exection.BusinessException;
import lombok.extern.slf4j.Slf4j;
import org.apache.batik.transcoder.TranscoderException;
import org.apache.batik.transcoder.TranscoderInput;
import org.apache.batik.transcoder.TranscoderOutput;
import org.apache.batik.transcoder.image.PNGTranscoder;

import java.io.*;
import java.nio.charset.StandardCharsets;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;

/**
 * @author penglibo
 * @date 2024-11-01 23:37:24
 * @since jdk 1.8
 */

@Slf4j
public class FileUtil {

    /**
     * 压缩文件
     * @param zipOutputStream 压缩文件流
     * @param filename        文件名称
     * @param in              待压缩文件流
     */
    public static void toZip(ZipOutputStream zipOutputStream, String filename, InputStream in) {
        BufferedInputStream bis = null;
        try {
            bis = new BufferedInputStream(in);
            //设置压缩包内文件的名称
            zipOutputStream.putNextEntry(new ZipEntry(filename));
            int size;
            byte[] buffer = new byte[4096];
            while ((size = bis.read(buffer)) > 0) {
                zipOutputStream.write(buffer, 0, size);
            }
            zipOutputStream.closeEntry();
        } catch (Exception e) {
            throw new BusinessException("压缩文件失败");
        } finally {
            //关闭资源
            if (null != bis) {
                try {
                    bis.close();
                } catch (IOException e) {
                    log.error(e.getMessage());
                }
            }
        }
    }

    /**
     * svg 转换为 png 图片
     */
    public static byte[] svg2Png(String svgXml) throws TranscoderException, IOException {
        // 将 svg 图片转换为 png 保存
        InputStream svgStream = new ByteArrayInputStream(svgXml.getBytes(StandardCharsets.UTF_8));
        TranscoderInput input = new TranscoderInput(svgStream);
        // png 图片生成器
        PNGTranscoder transcoder = new PNGTranscoder();
        ByteArrayOutputStream outStream = new ByteArrayOutputStream();
        TranscoderOutput output = new TranscoderOutput(outStream);
        transcoder.transcode(input, output);
        outStream.close();
        return outStream.toByteArray();
    }
}
````

- 之前的 ModelerVO 用户信息从工具类获取，免得后面整合了忘掉了，整合好之后调整 SecurityUtil 工具类就好了

`io.github.cmmplb.activiti.domain.vo.ModelerVO`

````java
public String getCreatedByUser() {
    return SecurityUtil.getUserName();
}
````

## 前端页面

- 添加 deployment/index.vue 页面，布局还是跟模型管理页面一样，使用之前封装好的 table 组件渲染

````vue

<template>
  <div class='deployment-container'>
    <!-- 通过shadow属性设置卡片阴影出现的时机：always、hover或never -->
    <el-card shadow="always" class="search-card">
      <!-- 搜索表单区域 -->
      <!-- inline 属性可以让表单域变为行内的表单域 -->
      <el-form inline :model="searchForm" class="search-form">
        <el-row>
          <el-col :span="4">
            <el-form-item label="关键词">
              <el-input class="search-type-options" v-model="searchForm.keywords" clearable
                        placeholder="关键词"></el-input>
            </el-form-item>
          </el-col>
          <el-col :span="3">
            <el-form-item>
              <el-button type="primary" icon="Search" @click="handlerSearch">查 询</el-button>
            </el-form-item>
          </el-col>
        </el-row>
      </el-form>
    </el-card>

    <el-card shadow="always" class="content-card">
      <!-- 新增按钮区域 -->
      <el-form inline>
        <el-form-item>
          <el-button
              icon="Plus"
              type="primary"
              plain
              @click="handlerUpload"
          >
            上传流程文件
          </el-button>
        </el-form-item>
      </el-form>

      <!-- 表格区域 -->
      <Table
          :columns="columns"
          :data="data"
          showPagination
          @pagination="paginationChange"
          :paginationData="paginationData"
      >
        <template #buttons>
          <el-table-column fixed="right" align="center" label="操作" min-width="120" width="240">
            <template #default="scope">
              <el-button
                  icon="Delete"
                  @click="handlerDelete(scope.row)"
                  text
                  style="color: red"
              >删除
              </el-button
              >
            </template>
          </el-table-column>
        </template>
      </Table>
    </el-card>

    <!-- 文件上传弹窗, 在 vue3 中 el-dialog 把 visible 属性改为了 v-model -->
    <el-dialog title="上传流程文件" v-model="visible" style="max-width: 500px;padding: 50px"
               :before-close="handleClose">
      <!--
        上传组件: https://element-plus.org/zh-CN/component/upload.html
        drag-是否启用拖拽上传-boolean-false; multiple-是否支持多选文件-boolean-false; auto-upload-是否在文件选择后立即进行上传-boolean-true;
        :http-request-覆盖默认的 Xhr 行为，自定义实现上传文件的请求事件, 添加处理点击确认才调用上传
        vue3 更换了 :file-list 为 v-model:file-list
       -->
      <el-upload ref="uploadRef" class="upload" drag multiple :auto-upload="false" v-model:file-list="fileList">
        <i class="el-icon-upload"></i>
        <div class="el-upload__text">将流程文件拖到此处，或<em>点击上传</em></div>
        <div class="el-upload__tip" slot="tip">提示: 仅允许导入 "bpmn", "xml" 或 "zip" 格式文件！</div>
      </el-upload>
      <template #footer>
        <div class="dialog-footer">
          <el-button @click="handleClose">取 消</el-button>
          <el-button type="primary" @click="handlerConfirm">确 定</el-button>
        </div>
      </template>
    </el-dialog>
  </div>
</template>

<script setup lang="ts">

  import Table from '@/components/table/index.vue';
  import {onMounted, reactive, ref} from 'vue';
  import {QueryPageBean} from '@/utils/http/axios/axios';
  import {getByPaged, removeById, upload} from '@/api/process/deployment.ts';
  import {ElMessage, ElMessageBox, UploadInstance, UploadUserFile} from 'element-plus';

  // reactive 一般定义响应式数据, 例如数组、对象等, ref 一般定义基础类型数据, 例如字符串、数字等

  // 表格列配置
  const columns = reactive<Column[]>([
    {
      prop: 'name',
      label: '部署名称',
      width: 300
    },
    {
      prop: 'key',
      label: '关键字',
      width: 500
    },
    {
      prop: 'category',
      label: '类型',
      width: 300
    },
    {
      prop: 'version',
      label: '版本',
      width: 140
    },
    {
      prop: 'deploymentTime',
      label: '部署时间'
    }

  ]);
  // 表格数据集
  const data = ref([]);
  // 搜索表单
  const searchForm = reactive<QueryPageBean>({
    keywords: ''
  });
  // 分页参数
  const paginationData = reactive<Pagination>({
    size: 10,
    current: 1,
    total: 0
  });
  // 上传部署列表, { name: '...', url: '....' }
  const fileList = ref<UploadUserFile[]>([]);
  // 上传流程文件弹窗是否显示
  const visible = ref(false);

  // 挂载完毕后执行的回调函数
  onMounted(() => {
    getData();
  });

  // 点击搜索按钮
  const handlerSearch = () => {
    getData();
  };

  // 获取表格数据
  const getData = async () => {
    const res = await getByPaged({...searchForm, ...paginationData});
    if (res.code === 200 && res.data) {
      data.value = res.data.rows;
      paginationData.total = res.data.total;
    } else {
      ElMessage({message: res.msg, type: 'error'});
    }
  };

  // 分页改变调用的事件
  const paginationChange = (data: any) => {
    // 把原来的值覆盖
    Object.assign(paginationData, {...paginationData, ...data});
    getData();
  };

  // 点击上传流程文件按钮
  const handlerUpload = () => {
    visible.value = true;
    fileList.value = [];
  };

  // 点击删除按钮
  const handlerDelete = (row: ModelVO) => {
    ElMessageBox.confirm('是否确认删除"' + row.id + '"的数据项？', '删除', {
          confirmButtonText: '确定',
          cancelButtonText: '取消',
          type: 'warning'
        }
    ).then(async () => {
      const res = await removeById(row.id);
      if (res.code === 200 && res.data) {
        await getData();
        ElMessage({type: 'success', message: '删除成功'});
      } else {
        ElMessage({type: 'error', message: res.msg});
      }
    }).catch(() => {
      // 取消删除
    });
  };

  // 关闭上传流程文件弹窗
  const handleClose = () => {
    visible.value = false;
  };

  // Vue 3 写法, 获取 ref 定义的组件实例
  const uploadRef = ref<UploadInstance>();

  // 确定上传
  const handlerConfirm = async () => {
    // 手动提交上传，会调用http-request事件
    // uploadRef.value!.submit();
    let formData = new FormData();
    // 这里上传文件我之前写的是 formData.append('files', ele); 控制台查看参数是 files: [object Object]
    // 需要把上传的文件转换成二进制对象, Blob/file.raw(.raw 就是上传的 binary), 参数: files: （二进制）或者 files: (binary) 才是正确的
    fileList.value.forEach(ele => {
      // 注意要添加 .raw
      formData.append('files', ele.raw!);
      // 或者使用 blob
      // formData.append('files', new Blob([ele.raw!]));
    });
    const res = await upload(formData);
    if (res.code === 200 && res.data) {
      ElMessage({type: 'success', message: '上传成功'});
      // 刷新列表
      await getData();
      // 关闭弹窗
      handleClose();
    } else {
      ElMessage({type: 'error', message: res.msg});
    }
  };
</script>

<style scoped lang='scss'>
  .deployment-container {
    .upload {
      .el-upload__tip {
        margin-top: 15px;
        color: red;
      }
    }
  }

</style>
````

- api 和 ts 类型声明：

`spring-boot-activiti/web/src/api/process/deployment.ts`

````typescript
import request from '@/utils/http/axios';
import {PageResult, QueryPageBean, Result} from '@/utils/http/axios/axios';

enum Api {
  BASE = '/deployment',
  PAGED = BASE + '/paged',
  UPLOAD = BASE + '/upload',
  REMOVE = BASE + '/',
}

/**
 * 分页条件查询列表
 */
export const getByPaged = (data: QueryPageBean) => {
  return request.post<Result<PageResult<DeploymentVO>>>({
    url: Api.PAGED,
    data
  });
};

/**
 * 上传部署流程文件
 */
export const upload = (data: FormData) => {
  return request.post<Result<boolean>>({
    url: Api.UPLOAD,
    data
  });
};

/**
 * 根据id删除
 */
export const removeById = (id: string) => {
  return request.delete<Result<boolean>>({
    url: Api.REMOVE + id
  });
};
````

`spring-boot-activiti/web/src/api/process/types/deployment.d.ts`

````typescript
// declare关键字用于告诉编译器某个标识符已经存在，但不需要进行类型检查
declare interface DeploymentVO {
  id: string;
  name: string;
  key: string;
  category: string;
  deploymentTime: string;
  version: number;
}
````

- 路由和菜单信息

`spring-boot-activiti/web/src/router/index.ts`

````typescript
// 公共静态路由
const constantRoutes = [
  {
    path: '/process',
    component: Layout,
    // 重定向到 /process, 效果是访问 /process 重定向到 /process/model
    redirect: '/process/model',
    children: [
      // ...
      {
        path: '/process/deployment',
        component: () => import ('@/views/process/deployment/index.vue'),
        name: '部署管理'
      }
    ]
  }
];
````

`spring-boot-activiti/web/src/const/constant.ts`

````typescript
/**
 * 菜单列表, 后续可以从后台获取
 */
export const menuList = reactive<Array<Menu>>([
    {
      children: [
        // ...
        {
          'id': 4,
          'name': '部署管理',
          'icon': 'VideoPlay',
          'path': '/process/deployment',
          'parentId': 2
        }
      ]
    }
  ]);
````

- 重启项目，查看部署、导出、上传流程图以及删除部署的情况，对照着表多试几个数据，相关功能的注释都写在代码里了，就不在 md 过多描述了。

目前整合到模型和流程，关联的表:

- act_re_deployment
- act_re_model
- act_re_procdef

还没有赋值的字段：TENANT_ID_ 和 ENGINE_VERSION_，TENANT_ID 等后续整合租户再弄，这个 ENGINE_VERSION 字段找了翻了一天源码硬是没看到哪里能设置，只有
DeploymentEntity 才有 void setEngineVersion(String engineVersion)，就先空着，后面看能找到使用规则不。

## bug

1. 报错: cvc-datatype-valid.1.2.1: '0ee903b8-9695-11ef-beca-d6edbbd75e0a' 不是 'NCName' 的有效值。
   `io.github.cmmplb.activiti.service.impl.ModelServiceImpl.saveJsonXml`

- 流程唯一标识, 必须是下划线或者字母开头

````
properties.put(StencilConstants.PROPERTY_PROCESS_ID, id);
改为：
properties.put(StencilConstants.PROPERTY_PROCESS_ID, "_" + id);
````

2. 控制台警告, [el-radio] [API] label act as value is about to be deprecated in version 3.0.0, please use value instead.

````vue

<el-form-item label="模型设计类型" prop="designType">
  <el-radio-group v-model="form.designType">
    <!-- 未来版本将移除 :label 改为 :value -->
    <el-radio :key="1" :value="1">activiti-modeler</el-radio>
    <el-radio :key="2" :value="2">bpmn-js</el-radio>
  </el-radio-group>
</el-form-item>
````